/*
Written by: James Wigglesworth 
Started: 5_21_19
Updated: 12_17_19

Overview:
#A User Input
#B Globals
#C init_globals()
#D init_robot()
#E find_idx_eyes()
	#E1 is_idx_eye()
    #E2 AdcCenters string conversions
#F set_found_position()
#G Find_Idx_Eyes Job Def
#H Test_All_States Job Def
*/

/*
INSTRUCTIONS:

1.  tune opto pots 
2.  select center and save
3.  reboot
3.5 Check_Eye_Order
4.  Cal
5.  Follow mode to validate Cal

6. pause
7.  Initial_Scan
8.  Save_Scan_Results when intial scan looks good
9.  Boot in any position
10. Find_Idx_Eyes_Setup
11. Power cycle
12. Find_Idx_Eyes_Setup and the idx_eye_to_cal_offset should be [0,0,0,0,0]

13. Power off
14. Manually move to where you want to define home to be
15. Power on
15.5 Check_Eye_Order
15.7 Center_Eye
16. Find_Idx_Eyes_Setup
17. Save_Eye_Offset (It looks like this is a constant [-2, 1, -2, -2, -2], to change it change the variable 'actual_eye_offset')
18. go home
18.5 Center_Eye
19. Cal
20. post_cal_info (this now saves post_cal_info.JSON to Dexter)
21. Power off

22. Move to an random position
23. Power on
23.5 Check_Eye_Order
23.6 Center_Eye
24. Find_Idx_Eyes to confirm it works


To adjust a threshold after :
1. Eval 'scan_result'
2. Click 'Object' on desired joint number
3. Click 'Object' under the 'cos' field
4. Remember values for ddx_idx_min and ddx_non_idx_max
5. Go into 'ddx_sorted' array and look for those values
   The numbers under the 'val' feild correspond to the 'Cos ddx Sorted' plot
6. Choose the point you want to include as an index eye.
7. Set the threshold of the given joint to the average of the chosen point and the one below it:
   scan_result[0].ddx_thresh = (643 + 379) / 2
8. Run Save_Scan_Results to save thresholds to the robot



*/




/*
w, 42, 832
make_ins('w', 42, 832)
set eye number`	
set commanded angle
*/


//#A User Input:
var initial_direction = [-1, -1, -1, 1, -1]
var slow_step_size = [1000*_arcsec, 1000*_arcsec, 1000*_arcsec, 1000*_arcsec,  1000*_arcsec]//[0, 0, 0, 0, 100*_arcsec]
var rapid_steps_per_eye = [15, 15, 15, 15, 15]
var idid = 0
var n_eyes = [200, 180, 157, 113, 100]
var max_eye_spacing = [30, 30, 30, 30, 14]

//var idx_eye_to_cal_offset = [5, -6, 8, -5, 0]
//var idx_eye_to_cal_offset = [0, 0, 0, 0, 0]
// out(Vector.subtract([255, 255, 255, 255, 255], true_home_eye))
//var post_cal_info = JSON.parse(file_content("C:/Users/james/Documents/dde_apps/2019/_Code/Misc/EncoderIdeas/on_bootup_info"))
var tweek_angles = [5.5125, 0.03333333333333333, 0.0225, 0.013125, 0.046875]
var file_on_dexter_name = "/srv/samba/share/Index_Eye_Data.JSON"
var file_on_dexter_name_post_cal = "/srv/samba/share/post_cal_info.JSON"

/*
var temp = [
	Dexter.dexter0.robot_status[Dexter.J1_ANGLE],
    Dexter.dexter0.robot_status[Dexter.J2_ANGLE],
    Dexter.dexter0.robot_status[Dexter.J3_ANGLE],
    Dexter.dexter0.robot_status[Dexter.J4_ANGLE],
    Dexter.dexter0.robot_status[Dexter.J5_ANGLE]
]
*/
//#B Globals:
var deg_per_eye
var step_size
var start_time
var start_EyeNumber
var old_EyeNumber
var old_RawEncoder
var AdcCenters_array
var prev_eye_cos_vals
var prev_eye_sin_vals
var cur_commanded_pos
var cos_maxes
var sin_maxes
var cur_direction
var first_idx_eye
var second_idx_eye
var spacing_to_eye_offset
var final_eye_offset
var cos_to_center_block_offset
//var cw_spacing_to_eye_offset
//var ccw_spacing_to_eye_offset
var spacing_idx
var final_angle_offset
var stage_idx
var stage_string_array
var true_home_eye
var neg_spacing_to_eye_offset
var pos_spacing_to_eye_offset
var all_cos_vals
var all_sin_vals
var all_eyes

var scan_data
var scan_result
var cos_diff_thres
var sin_diff_thres
var eyes_between_sensors
var info_raw_idx_eye
var info_post_calibration
//var idx_eye_to_cal_offset
var EyeNumber
var waiting_eyes
var all_waiting
var idx_eye_to_cal_offset
var post_cal_info
var goal_angle_in_eye
//idx: [255, 261, 247, 261, 256]
//cal: [258,255,255,255,255]
//var diff = Vector.subtract([258,255,255,255,255], [255, 261, 247, 261, 256])

//#C init_globals():
function init_globals(){    
    deg_per_eye = Vector.divide(360, n_eyes)
    step_size = Vector.multiply(Vector.abs(slow_step_size), initial_direction)
    prev_eye_cos_vals = [[], [], [], [], []]
    prev_eye_sin_vals = [[], [], [], [], []]
    all_cos_vals = [[], [], [], [], []]
    all_sin_vals = [[], [], [], [], []]
    all_eyes = [[], [], [], [], []]
    cos_maxes = [[], [], [], [], []]
    sin_maxes = [[], [], [], [], []]
    cur_commanded_pos = [0, 0, 0, 0, 0]
    cur_direction = JSON.parse(JSON.stringify(initial_direction))
    first_idx_eye = [0, 0, 0, 0, 0]
    second_idx_eye = [0, 0, 0, 0, 0]
    final_eye_offset = [0, 0, 0, 0, 0]
    spacing_to_eye_offset = [0]
    spacing_idx = [0, 0, 0, 0, 0]
    smart_scan_results = []
    smart_scan_found_eyes = []
    true_home_eye = [0, 0, 0, 0, 0]
    stage_idx = [0, 0, 0, 0, 0]
    waiting_eyes = [0, 0, 0, 0, 0]
    all_waiting = false
    stage_string_array = [
    	"find_eye_change",
        "find_first_index_eye",
        "find_second_index_eye",
        "waiting",
        "rapid_home",
        "find_home_eye",
        "angle_in_eye",
		"complete",
        "direction_change"
    ]
    
    let default_thres = 2000
    cos_diff_thres = [default_thres, default_thres, default_thres, default_thres, default_thres]
    sin_diff_thres = [default_thres, default_thres, default_thres, default_thres, default_thres]
    eyes_between_sensors = [0, 0, 0, 0, 0]
    idx_eye_to_cal_offset = [0, 0, 0, 0, 0]
    
    /*
    if(scan_result){
        for(let i = 0; i < cos_diff_thres.length; i++){
            if(Object.keys(scan_result[i]).length != 0){
                cos_diff_thres[i] = scan_result[i].cos.ddx_thresh
                sin_diff_thres[i] = scan_result[i].sin.ddx_thresh
                eyes_between_sensors[i] = scan_result[i].sin_eye_offset
            }
        }
    }else{
    	warning("scan_result is undefined. Default thresholds will be used. (Ignore if running Initial_Scan)")
    }
    */
    
    //cos_to_center_block_offset = Vector.multiply(0.5, (Vector.multiply(deg_per_eye, Vector.add(-0.25, eyes_between_sensors))))
    cos_to_home_offset = [0, 0, 0, 0, 0]
    
    /*
    //OLD:
    neg_spacing_to_eye_offset = [
    	null,
        null,
        0,
        3,
        -2,
        8,
        -6,
        15,
        -12,
        24,
        -20,
        35,
        -30,
        48,
        -42,
        63
    ]
    
    pos_spacing_to_eye_offset = [
    	null,
        null,
        -2,
        0,
        -6,
        3,
        -12,
        8,
        -20,
        15,
        -30,
        24,
        -42
    ]
    */
    
    neg_spacing_to_eye_offset = [
    	null, //0
		null, //1
		null, //2
		null, //3
		0, 	  //4 (3 regular slots, 1 index, after seeing an index.)
		5,	  //5 (was at zero, moved past 4 regular, 1 index.)
		-4,	  //6
		12,	  //7
		-10,  //8
		21,	  //9
		-18,  //10
		32,	  //11
		-28,  //12
		45,	  //13
		-40,  //14
		60,	  //15
		-54,  //16
		77,	  //17
		-70,  //18
    ]
    
    pos_spacing_to_eye_offset = [
    	null,  //0
		null,  //1
		null,  //2
		null,  //3
		-4,    //4 (3 regular slots, 1 index, after seeing an index.)
		0,	   //5 (was at five, moved past 4 regular, 1 index.)
		-10,   //6
		5,	   //7
		-18,   //8
		12,	   //9
		-28,   //10
		21,	   //11
		-40,   //12
		32,	   //13
		-54,   //14
		45,	   //15
		-70,   //16
		60,	   //17
		-88,   //18
    ]
    
    /*
	let cw_spacing = -2
	let cw_spacing_inc = -4
	let ccw_spacing = 3
	let ccw_spacing_inc = 5
    let max_offset = Vector.max(n_eyes) / 2
    let i = 0
	while(Math.abs(spacing_to_eye_offset[i]) < max_offset){
        i++
        if(i%2 == 0){
            spacing_to_eye_offset.push(ccw_spacing)
            ccw_spacing += ccw_spacing_inc
            ccw_spacing_inc += 2
			
        }else{
            spacing_to_eye_offset.push(cw_spacing)
            cw_spacing += cw_spacing_inc
            cw_spacing_inc -= 2
        }
	}
    spacing_to_eye_offset.pop()
    spacing_to_eye_offset.pop()
    spacing_to_eye_offset[0] = null
    out("Generated spacing to eye offset:" + spacing_to_eye_offset)
	*/
    
    
   // idx_eye_to_cal_offset = [0, 0, 0, 0, 0]//Vector.subtract(info_post_calibration.eyes, info_raw_idx_eye.eyes)
  goal_angle_in_eye = [45, 45, 45, 45, 45]
}


//#D init_robot():
function init_robot(short){
	return [
    	Dexter.set_parameter("MaxSpeed", 30),
    	Dexter.move_all_joints([0, 0, 0, 0, 0]), //remove this later
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
        Dexter.read_from_robot("#RawEncoders", "RawEncoders"),
        
        Dexter.read_from_robot("/srv/samba/share/AdcCenters.txt", "AdcCenters"),
        function(){out("Attempting to read " + file_on_dexter_name + "...<br\>If Job errors, generate this file by running Inital_Scan and Save_Scan_Results", "blue")},
        Dexter.read_from_robot(file_on_dexter_name, "IndexEyeData"),
        Dexter.read_from_robot(file_on_dexter_name_post_cal, "PostCalInfo"),
        
        function(){
        	start_time = Date.now()
            
            
            start_EyeNumber = JSON.parse(this.user_data.EyeNumbers)
            old_EyeNumber = JSON.parse(this.user_data.EyeNumbers)
            //let temp = old_EyeNumber[4]
            //old_EyeNumber[4] = old_EyeNumber[2]
            //old_EyeNumber[2] = temp
            old_RawEncoder = JSON.parse(this.user_data.RawEncoders)
        	let AdcCenters_string = this.user_data.AdcCenters
            AdcCenters_array = AdcCenters_string_to_array(AdcCenters_string)
            
            
            scan_result = JSON.parse(this.user_data.IndexEyeData)
        	for(let i = 0; i < cos_diff_thres.length; i++){
            	if(Object.keys(scan_result[i]).length != 0){
                	cos_diff_thres[i] = scan_result[i].cos.ddx_thresh
                	sin_diff_thres[i] = scan_result[i].sin.ddx_thresh
                	eyes_between_sensors[i] = scan_result[i].sin_eye_offset
                    idx_eye_to_cal_offset[i] = scan_result[i].idx_eye_to_cal_offset
            	}
        	}

            post_cal_info = JSON.parse(this.user_data.PostCalInfo)
            /*
            //let AdcCenters_string_array = AdcCenters_string.split("\r\n")
            let temp_string = AdcCenters_string_array[4]
            AdcCenters_string_array[4] = AdcCenters_string_array[2]
            AdcCenters_string_array[2] = temp_string
            temp_string = AdcCenters_string_array[5]
            AdcCenters_string_array[5] = AdcCenters_string_array[3]
            AdcCenters_string_array[3] = temp_string
            */
            
            print_stages()
            /*
            let saved_x = parseInt(centers_string[2*(showing_J_num-1)]) / 655360
    		let saved_y = parseInt(centers_string[2*(showing_J_num-1)+1]) / 655360
            
            centers_string[2*window.cal_working_axis] =
                "0x" + ((vals.offsetX  * 10) * 65536).toString(16)
            centers_string[2*window.cal_working_axis+1] =
                "0x" + ((y_val_to_save * 10) * 65536).toString(16)
            */
            
        }
    ]
}


//#E find_idx_eyes():
function find_idx_eyes(){
	return Robot.loop(
    	function(){
        	
            for(let i = 0; i < stage_idx.length; i++){
            	if(stage_string_array[stage_idx[i]] != "complete"){
                	return true
                }
			}
            /*
            if(stage_string_array[stage_idx[0]] == "complete" && stage_string_array[stage_idx[1]] == "complete" && stage_string_array[stage_idx[4]] == "complete"){
            	return false
            }
            return true
            */
            return false
    	}, 
    function(){
    	let CMD = []
    	CMD.push(Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"))
        CMD.push(Dexter.read_from_robot("#RawEncoders", "RawEncoders"))
        CMD.push(Dexter.empty_instruction_queue())
        CMD.push(function(){
        	
        	EyeNumber = JSON.parse(this.user_data.EyeNumbers)
            //bug in #EyeNumber where joints are switched:
            //let temp = EyeNumber[4]
            //EyeNumber[4] = EyeNumber[2]
            //EyeNumber[2] = temp
            
        	let rs = this.robot.robot_status
            let cos_val = [
            	rs[Dexter.J1_A2D_COS],
                rs[Dexter.J2_A2D_COS],
                rs[Dexter.J3_A2D_COS],
                rs[Dexter.J4_A2D_COS],
                rs[Dexter.J5_A2D_COS]
            ]
            let sin_val = [
            	rs[Dexter.J1_A2D_SIN],
                rs[Dexter.J2_A2D_SIN],
                rs[Dexter.J3_A2D_SIN],
                rs[Dexter.J4_A2D_SIN],
                rs[Dexter.J5_A2D_SIN]
            ]
            
            if(
            	stage_string_array[stage_idx[0]] == "waiting" &&
            	stage_string_array[stage_idx[1]] == "waiting" &&
                stage_string_array[stage_idx[2]] == "waiting" &&
                stage_string_array[stage_idx[3]] == "waiting" &&
                stage_string_array[stage_idx[4]] == "waiting"
            ){
            	all_waiting = true
            }
            
            let max_val = 4096
            //if(cos_val[i] > max_val){cos_val[i] = -Infinity} //wierd bug where this would jump to large value. maybe electrical shorts?? EDIT: bug in read_from_robot that overwrites robot status
			let stage
            for(let i = 0; i < EyeNumber.length; i++){
            	//check raw vs commanded for collisions here
                
                
                stage = stage_string_array[stage_idx[i]]
                if(stage == "find_eye_change"){
                	if(EyeNumber[i] != old_EyeNumber[i]){
                    	step_size[i] = cur_direction[i]*Math.abs(deg_per_eye[i]/rapid_steps_per_eye[i]) //fast step speed
                    	stage_idx[i]++ //go to next stage
                        cos_maxes[i] = []
                        print_stages()
                  	}
                }else if(stage == "find_first_index_eye" || stage == "find_second_index_eye"){
                    all_cos_vals[i].push(cos_val[i])
                	all_sin_vals[i].push(sin_val[i])
                	all_eyes[i].push(EyeNumber[i])
                    
                    if(EyeNumber[i] == old_EyeNumber[i]){
                        prev_eye_cos_vals[i].push(cos_val[i])
                        prev_eye_sin_vals[i].push(sin_val[i])
                    }else if(prev_eye_cos_vals[i].length > 0){
                    	cos_maxes[i].push(local_max(prev_eye_cos_vals[i]))
                    	sin_maxes[i].push(local_max(prev_eye_sin_vals[i]))
                        prev_eye_cos_vals[i] = []
                        prev_eye_sin_vals[i] = []
                        /*if(cos_maxes[i].length > max_eye_spacing[i]){
                        	out("max_eye_spacing of " + cos_maxes[i].length + " exceeded for J" + (i + 1))
                            step_size[i] = -deg_per_eye[i] * (EyeNumber[i] - start_EyeNumber[i] - 2*Math.sign(EyeNumber[i] - start_EyeNumber[i]))
                            stage_idx[i] = stage_string_array.indexOf("direction_change")
                            print_stages()
                        }else */
                        if(cos_maxes[i].length > 2){ //needs at least three maxes
                        	//if(i==0){debugger}
                            if(is_idx_eye(cos_maxes[i], cos_diff_thres[i])){
                            	if(stage == "find_first_index_eye"){
                                	first_idx_eye[i] = EyeNumber[i] - 2 * cur_direction[i] //triggers on n+1 eyes and idx is middle of 3 eyes
                                    stage_idx[i]++ //go to next stage
                                    print_stages()
                                }else{
                                	//if(i==2){debugger}
                                    waiting_eyes[i] = EyeNumber[i]
                                	stage_idx[i]++ //go to next stage
                        			print_stages()
                                }
                            }   
                        }
					}
                }else if(stage == "waiting"){
                    if(all_waiting){
                        second_idx_eye[i] = waiting_eyes[i] - 2 * cur_direction[i]
                        spacing_idx[i] = second_idx_eye[i] - first_idx_eye[i]
                        
                        //sign correction can be removed by flipping the code disk design
                        let sign_correction = [1, -1, 1, 1, 1]
                        //if(i==0){debugger}
                        if(sign_correction[i]*Math.sign(cur_direction[i]) == 1){
                        	final_eye_offset[i] = pos_spacing_to_eye_offset[Math.abs(spacing_idx[i])] + idx_eye_to_cal_offset[i]
                      	}else{
                        	final_eye_offset[i] = neg_spacing_to_eye_offset[Math.abs(spacing_idx[i])] + idx_eye_to_cal_offset[i]
                      		if(isNaN(final_eye_offset[i])){debugger}
                        }
                        if(i==1){final_eye_offset[1] *= -1}
                        
                      	true_home_eye[i] = second_idx_eye[i] + final_eye_offset[i]
                        step_size[i] = deg_per_eye[i] * (final_eye_offset[i] + Math.sign(EyeNumber[i] - start_EyeNumber[i]))
                        cur_direction[i] *= -1
                        stage_idx[i]++ //go to next stage
                        print_stages()
                    }else{
                    	if(EyeNumber[i] == waiting_eyes[i]){
                        	let x = cos_val[i] - AdcCenters_array[i][1]
                			let y = sin_val[i] - AdcCenters_array[i][0]
                			let atan2_val = atan2d(x, y)
                            step_size[i] = (-atan2_val) / 360 * deg_per_eye[i]
                        }else{
                        	step_size[i] = (waiting_eyes[i] - EyeNumber[i]) * deg_per_eye[i]
                        }
                    }
                }else if(stage == "rapid_home"){
                	step_size[i] = cur_direction[i]*Math.abs(deg_per_eye[i]/rapid_steps_per_eye[i])
                	stage_idx[i]++ //go to next stage
                    print_stages()
                }else if(stage == "find_home_eye"){
                	if(EyeNumber[i] == true_home_eye[i]){
                    	step_size[i] = 0
                		stage_idx[i]++ //go to next stage
                    	print_stages()
                    }else{
                    	cur_direction[i] = Math.sign(true_home_eye[i] - EyeNumber[i])
                    	step_size[i] = cur_direction[i]*Math.abs(deg_per_eye[i]/rapid_steps_per_eye[i])
                    }
                }else if(stage == "angle_in_eye"){
                	let cal_atan2 = goal_angle_in_eye[i]//post_cal_info.atan2[i]
                
                	let x = cos_val[i] - AdcCenters_array[i][1]
                	let y = sin_val[i] - AdcCenters_array[i][0]
                	let atan2_val = atan2d(x, y)
                    //if(i == 1) {
                	out("eye: " + EyeNumber[i] + " atan2_val: " + Vector.round(atan2_val, 2) + " cos: " + x + " sin: " + y + " cmd_angle: " + Vector.round(cur_commanded_pos, 3)[i])
                	//}
                    
                    
                    
                    /*
                    if(atan2_val == info_post_calibration.atan2[i]){ //replace '0' with variable
                		step_size[i] = 0
                        stage_idx[i]++ //go to next stage
                    	print_stages()
                    }else{
                    	step_size[i] = (info_post_calibration.atan2[i] - atan2_val) / 360 * deg_per_eye[i]
                    }
                    */
                    let J_angle_thresh = [1 * _arcsec, 1 * _arcsec, 1 * _arcsec, 5 * _arcsec, 5 * _arcsec]
					let E_angle_thresh = 360 * J_angle_thresh[i] / deg_per_eye[i]
                    if(i == 0){
                    	out(
                        	"J" + i + 
                            " Target Eye:" + true_home_eye[i] + 
                            " Actual Eye:" + EyeNumber[i] + 
                            " target atan2: " + Vector.round(cal_atan2, 5) + 
                            " actual atan2: " + Vector.round(atan2_val, 5) + 
                            " error: " + Vector.round(cal_atan2 - atan2_val, 5) +
                            " arcsec error: " + Math.round((cal_atan2 - atan2_val)/ 360 * deg_per_eye[1] / _arcsec)
                        )
                    }
                    if(Math.abs(cal_atan2 - atan2_val) < E_angle_thresh && true_home_eye[i] == EyeNumber[i]){ //replace '0' with variable
                		step_size[i] = 0
                        stage_idx[i]++ //go to next stage
                    	print_stages()
                    }else{
                        // (true_home_eye[i] - EyeNumber[i]) * deg_per_eye[i] 
                    	step_size[i] = .25 * ((cal_atan2 - atan2_val) / 360 * deg_per_eye[i] + (true_home_eye[i] - EyeNumber[i]) * deg_per_eye[i])
                    }
                    
                }else if(stage == "complete"){
                	step_size[i] = 0
                    //load tables??
                }else if(stage == "direction_change"){
                	dde_error("direction_change stage not written yet")
                }else{
                	dde_error("Invalid stage: " + stage + " for J" + (i+1) + ", stage_idx: " + stage_idx[i]) 
                }   
            }
            old_EyeNumber = EyeNumber
        })
        CMD.push(function(){return Dexter.move_all_joints(cur_commanded_pos = Vector.add(step_size, cur_commanded_pos))})
        CMD.push(Dexter.empty_instruction_queue())

        return CMD
    })
}


//#E1 is_idx_eye():
function is_idx_eye(maxes, diff_threshold){
	let max_new = maxes[maxes.length - 1]
    let max_cur = maxes[maxes.length - 2]
    let max_old = maxes[maxes.length - 3]
    let cos_diff_old = max_cur - max_old
    let cos_diff_new = max_new - max_cur
    let ddx = cos_diff_new - cos_diff_old
    if(ddx > diff_threshold && cos_diff_old < 0 && cos_diff_new > 0){
    	return true
    }else{
    	return false
    }
    
    /*
	if(cos_diff_old < -diff_threshold && cos_diff_new > diff_threshold){
    	return true
    }else{
    	return false
    }
    */
}


//#E2 AdcCenters string conversions:
function AdcCenters_string_to_array(AdcCenters_string){
    let AdcCenters_string_array = AdcCenters_string.split("\r\n")
    let temp_string = AdcCenters_string_array[4]
    AdcCenters_string_array[4] = AdcCenters_string_array[2]
    AdcCenters_string_array[2] = temp_string
    temp_string = AdcCenters_string_array[5]
    AdcCenters_string_array[5] = AdcCenters_string_array[3]
    AdcCenters_string_array[3] = temp_string
	let AdcCenters_array = []
    for(let i = 0; i < 10; i+=2){
    	AdcCenters_array.push([
        	parseInt(AdcCenters_string_array[i]) / 65536,
            parseInt(AdcCenters_string_array[i+1]) / 65536
        ])
    }
    return AdcCenters_array
}

function AdcCenters_array_to_string(AdcCenters_array){
	let AdcCenters_string_array = []
    for(let i = 0; i < 5; i++){
    	AdcCenters_string_array.push("0x" + (AdcCenters_array[i][0] * 65536).toString(16))
        AdcCenters_string_array.push("0x" + (AdcCenters_array[i][1] * 65536).toString(16))
    }
    let temp_string = AdcCenters_string_array[4]
    AdcCenters_string_array[4] = AdcCenters_string_array[2]
    AdcCenters_string_array[2] = temp_string
    temp_string = AdcCenters_string_array[5]
    AdcCenters_string_array[5] = AdcCenters_string_array[3]
    AdcCenters_string_array[3] = temp_string
    let AdcCenters_string = ""
    for(let i = 0; i < AdcCenters_string_array.length; i++){
    	AdcCenters_string += AdcCenters_string_array[i] + "\r\n"
    }
    return AdcCenters_string
}

//#E3 print_stages():
function print_stages(){
	let str = ""
    for(let i = 0; i < stage_idx.length-1; i++){
    	str += stage_string_array[stage_idx[i]] + " | "
    }
    str += stage_string_array[stage_idx[stage_idx.length-1]]
	out(str, "blue")
}

//#F set_found_position():
function set_found_position(){
	
	//final_angle_offset = Vector.add(cur_commanded_pos, Vector.add(Vector.multiply(1, Vector.multiply(Vector.add(0, final_eye_offset), deg_per_eye)), cos_to_center_block_offset))
    //out("true_home: " + Vector.round(final_angle_offset, 2) + " final_eye_offset: " + final_eye_offset)
    //return Dexter.move_all_joints(final_angle_offset)
    
    /*
    final_angle_offset = Vector.add(cur_commanded_pos, Vector.add(Vector.multiply(1, Vector.multiply(Vector.add(0, final_eye_offset), deg_per_eye)), cos_to_center_block_offset))
	
     
    let new_EyeNumbers = Vector.subtract([255, 255, 255, 255, 255], final_eye_offset)
    let EyeNumber = JSON.parse(this.user_data.EyeNumbers)
    //bug in #EyeNumber where joints are switched:
    let temp = EyeNumber[4]
    EyeNumber[4] = EyeNumber[2]
    EyeNumber[2] = temp
	*/
    rs = this.robot.robot_status
    
    /*
    return [
    	Dexter.set_parameter("EyeNumbers", new_EyeNumbers)
    ]
    */

	let i = 1
	plot_find_idx_eye_data(all_cos_vals[i], all_eyes[i], first_idx_eye[i], second_idx_eye[i], i)
}

/*

new Job({
	name: "Write_Dex_Files",
    inter_do_item_dur: idid,
    show_instructions: false,
    do_list: [
    	init_globals,
    	function(){
        	
        	//scan_result = process_scan_data(scan_data)
            //for(let i = 0; i < 5; i++){
            //	scan_result[i].cos = {}
            //    scan_result[i].cos.ddx_thresh = 0
            //    scan_result[i].sin = {}
            //    scan_result[i].sin.ddx_thresh
            //   scan_result[i].sin_eye_offset = 0
            //    scan_result[i].idx_eye_to_cal_offset = 0
            //}
            
            post_cal_info = {
            	eyes: [0, 0, 0, 0, 0],
                cos: [0, 0, 0, 0, 0],
                sin: [0, 0, 0, 0, 0],
                atan2: [0, 0, 0, 0, 0],
                Adc: [0, 0, 0, 0, 0],
                PID_deltas: [0, 0, 0, 0, 0]
            }
			return [
            	//Dexter.write_to_robot(JSON.stringify(scan_result), file_on_dexter_name),
        		Dexter.write_to_robot(JSON.stringify(post_cal_info), file_on_dexter_name_post_cal)
            ]
        },
    	
    ]
})
*/




new Job({
	name: "Check_Eye_Order",
    show_instructions: false,
	do_list: [
    	
    	Dexter.move_all_joints([0, 0, 0, 0, 0]),
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
		Dexter.empty_instruction_queue(),
        function(){
        	out("Eyes: " + this.user_data.EyeNumbers)
        },
        function(){
        	let CMD = []
            let angles = [0, 0, 0, 0, 0]
            let angle = 10
            for(let i = 0; i < 5; i++){
            	angles[i] = angle
            	CMD.push(Dexter.move_all_joints(angles))
        		CMD.push(Dexter.empty_instruction_queue())
    			CMD.push(Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"))
				CMD.push(Dexter.empty_instruction_queue())
        		CMD.push(function(){
        			out("Eyes: " + this.user_data.EyeNumbers)
                })
                angles = [0, 0, 0, 0, 0]
                CMD.push(Dexter.move_all_joints(angles))
                CMD.push(Dexter.empty_instruction_queue())
        }
            return CMD
        }
    ]
})

var FPGA = {
	BASE_POSITION: 0,
    END_POSITION: 1,
    PIVOT_POSITION: 2,
    ANGLE_POSITON: 3,
    ROT_POSITION: 4,
    ACCELERATION_MAXSPEED: 5,
    BASE_SIN_CENTER: 6,
    BASE_COS_CENTER: 7,
    END_SIN_CENTER: 8,
    END_COS_CENTER: 9,
    PIVOT_SIN_CENTER: 10,
    PIVOT_COS_CENTER: 11,
    ANGLE_SIN_CENTER: 12,
    ANGLE_COS_CENTER: 13,
    ROT_SIN_CENTER: 14,
    ROT_COS_CENTER: 15,
    PID_DELTATNOT: 16,
    PID_DELTAT: 17,
    PID_D: 18,
    PID_I: 19,
    PID_P: 20,
    PID_ADDRESS: 21,
    BOUNDRY_BASE: 22,
    BOUNDRY_END: 23,
    BOUNDRY_PIVOT: 24,
    BOUNDRY_ANGLE: 25,
    BOUNDRY_ROT: 26,
    SPEED_FACTORA: 27,
    SPEED_FACTORB: 28,
    FRICTION_BASE: 29,
    FRICTION_END: 30,
    FRICTION_PIVOT: 31,
    FRICTION_ANGLE: 32,
    FRICTION_ROT: 33,
    MOVE_TRHESHOLD: 34,
    F_FACTOR: 35,
    MAX_ERROR: 36,
    FORCE_BIAS_BASE: 37,
    FORCE_BIAS_END: 38,
    FORCE_BIAS_PIVOT: 39,
    FORCE_BIAS_ANGLE: 40,
    FORCE_BIAS_ROT: 41,
    COMMAND_REG: 42,
    DMA_CONTROL: 43,
    DMA_WRITE_DATA: 44,
    DMA_WRITE_PARAMS: 45,
    DMA_WRITE_ADDRESS: 46,
    DMA_READ_PARAMS: 47,
    DMA_READ_ADDRESS: 48,
    REC_PLAY_CMD: 49,
    REC_PLAY_TIMEBASE: 50,
    DIFF_FORCE_TIMEBASE: 51,
    DIFF_FORCE_BETA: 52,
    DIFF_FORCE_MOVE_THRESHOLD: 53,
    DIFF_FORCE_MAX_SPEED: 54,
    DIFF_FORCE_SPEED_FACTOR_ANGLE: 55,
    DIFF_FORCE_SPEED_FACTOR_ROT: 56,
    DIFF_FORCE_ANGLE_COMPENSATE: 57,
    FINE_ADJUST_BASE: 58,
    FINE_ADJUST_END: 59,
    FINE_ADJUST_PIVOT: 60,
    FINE_ADJUST_ANGLE: 61,
    FINE_ADJUST_ROT: 62,
    RECORD_LENGTH: 63,
    END_EFFECTOR_IO: 64,
    SERVO_SETPOINT_A: 65,
    SERVO_SETPOINT_B: 66,
    BASE_FORCE_DECAY: 67,
    END_FORCE_DECAY: 68,
    PIVOT_FORCE_DECAY: 69,
    ANGLE_FORCE_DECAY: 70,
    ROTATE_FORCE_DECAY: 71,
    PID_SCHEDULE_INDEX: 72,
    GRIPPER_MOTOR_CONTROL: 73,
    GRIPPER_MOTOR_OFF_WIDTH: 74,
    GRIPPER_MOTOR_ON_WIDTH: 75,
    START_SPEED: 76,
    ANGLE_END_RATIO: 77,
    CMD2: 78,
    PID_TIMEBASE: 79,
    PHYSICS_XYZ_TIMEBASE: 80,
    PHYSICS_DIFF_TIMEBASE: 81
}

FPGA.cmd_reg_val = function({
	CapCalibrateBase = false,
    CapCalibrateEnd = false,
    CapCalibratePivot = false,
    MoveEnable = false,
    GoMove = false,
    EnableLoop = false,
    AClrLoop = false,
    CAL_RUN = false,
    ResetMotorPosition = false,
    ResetForce = false,
    CapCalAngle = false,
    CapCalRot = false,
    AngleEnable = false,
    RotEnable = false,
}={}){
	let result = 0
    if(CapCalibrateBase){   result += 1}
    if(CapCalibrateEnd){    result += 2}
    if(CapCalibratePivot){  result += 4}
    if(MoveEnable){         result += 8}
    if(GoMove){             result += 16}
    if(EnableLoop){         result += 32}
    if(AClrLoop){           result += 64}
    if(CAL_RUN){            result += 128}
    if(ResetMotorPosition){ result += 256}
    if(ResetForce){         result += 512}
    if(CapCalAngle){        result += 1024}
    if(CapCalRot){          result += 2048}
    if(AngleEnable){        result += 4096}
    if(RotEnable){          result += 8192}
    return result
}

FPGA.cmd_reg_val({
	EnableLoop: true,
    CAL_RUN: true,
    ResetForce: true,
    AngleEnable: true,
    RotEnable: true
})

var atan2_vals, atan2_goal, J_error_thres, E_error_thresh, J_error
new Job({
	name: "Center_Eye",
    inter_do_item_dur: 0.001,
    show_instructions: false,
    do_list: [
        	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
        Dexter.read_from_robot("#RawEncoders", "RawEncoders"),
        
        Dexter.read_from_robot("/srv/samba/share/AdcCenters.txt", "AdcCenters"),


    	function(){
        	J_error_thres = [10*_arcsec, 10*_arcsec, 10*_arcsec, 40*_arcsec, 40*_arcsec]
            
        	atan2_vals = [Infinity, Infinity, Infinity, Infinity, Infinity]
            atan2_goal = [45, 45, 45, 45, 45]
            J_error = [Infinity, Infinity, Infinity, Infinity, Infinity]
            E_error_thresh = Vector.divide(Vector.multiply(360, J_error_thres), deg_per_eye)
        },
    	Robot.loop(
        	function(){
            
            	let result = false
                for(let i = 0; i < atan2_vals.length; i++){
                	if(!(Math.abs(J_error[i]) < J_error_thres[i])){
                    	result = true
                    }
                }
                return result
            },
            function(){
            	let CMD = []
                CMD.push(Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"))
                CMD.push(function(){EyeNumber = JSON.parse(this.user_data.EyeNumbers)}),
                CMD.push(Dexter.get_robot_status())
                CMD.push(function(){
                	let rs = this.robot.robot_status
            		let cos_val = [
            			rs[Dexter.J1_A2D_COS],
                		rs[Dexter.J2_A2D_COS],
                		rs[Dexter.J3_A2D_COS],
                		rs[Dexter.J4_A2D_COS],
                		rs[Dexter.J5_A2D_COS]
            		]
            		let sin_val = [
            			rs[Dexter.J1_A2D_SIN],
                		rs[Dexter.J2_A2D_SIN],
                		rs[Dexter.J3_A2D_SIN],
                		rs[Dexter.J4_A2D_SIN],
                		rs[Dexter.J5_A2D_SIN]
            		]
                    let cur_angles = [
            			rs[Dexter.J1_ANGLE],
                		rs[Dexter.J2_ANGLE],
                		rs[Dexter.J3_ANGLE],
                		rs[Dexter.J4_ANGLE],
                		rs[Dexter.J5_ANGLE]
            		]
                    
                    let x, y
                    let step = [0, 0, 0, 0, 0]
                    let str = ""
                    for(let i = 0; i < 5; i++){
            			x = cos_val[i] - AdcCenters_array[i][1]
                		y = sin_val[i] - AdcCenters_array[i][0]
                		atan2_vals[i] = atan2d(x, y)
                        atan2_error = atan2_goal[i] - atan2_vals[i]
                        J_error[i] = .25 * atan2_error * deg_per_eye[i] / 360
                        step[i] =  J_error[i]
                        //str += "| " + EyeNumber[i] + ", " + Vector.round(atan2_error, 3) + ", " + Math.round(J_error[i]/_arcsec) + " "
                    	str += "| " + EyeNumber[i] + ", " + Math.round(J_error[i]/_arcsec) + " "
                    }
                    out(str, "blue")
                    return Dexter.move_all_joints(Vector.add(cur_angles, step))
                })
                CMD.push(Dexter.empty_instruction_queue())
                
                return CMD
            }
        ),
        Dexter.sleep(1),
            make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val({
            	ResetMotorPosition: true,
        	})),
            make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val({
            	ResetMotorPosition: false,
        	})),
            Dexter.empty_instruction_queue(),
            function(){out("Done")}
    ]
})    



var start_time
var end_time
//This is moved here for sequential order of the Jobs
new Job({
	name: "Initial_Scan",
    inter_do_item_dur: idid,
    show_instructions: false,
    do_list: [
    	function(){start_time = Date.now()},
    	
        
        init_globals,
        init_robot,
        function(){scan_data = [[], [], [], [], []]},
        
        
        
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[0] = []},
    	function(){return do_scan(0, [-180, 180], 360/n_eyes[0] / 15)},
		
        
        
		Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[1] = []},
        function(){return do_scan(1, [-100, 100], 360/n_eyes[1] / 15)},
		
        
        
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[2] = []},
        function(){return do_scan(2, [-135, 135], 360/n_eyes[2] / 15)},
        
        
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[3] = []},
        function(){return do_scan(3, [-95, 95], 360/n_eyes[3] / 15)},
        
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[4] = []},
        function(){return do_scan(4, [-150, 150], 360/n_eyes[4] / 15)},
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
     	
        function(){
        	end_time = Date.now()
            out("Initial_Scan time: " + Vector.round(((end_time-start_time)/ 1000), 0) + " seconds")
        },
        
        
        function(){
        	scan_result = process_scan_data(scan_data)
            inspect(scan_result)
            //plot_scan_data(scan_data, scan_result, 1)
            
            for(let i = 0; i < 5; i++){
            	plot_scan_data(scan_data, scan_result, i)
            }
            
            
        }
	]
})


new Job({
	name: "Save_Scan_Results",
    inter_do_item_dur: 0,
    show_instructions: false,
    do_list: [
    	function(){
        	let content = JSON.stringify(scan_result)
			return Dexter.write_to_robot(content, file_on_dexter_name)
        }
    ]
})


//#G Find_Idx_Eyes Job Def:
new Job({
	name: "Find_Idx_Eyes_Setup",
    inter_do_item_dur: idid,
    show_instructions: false,
    do_list: [
    	init_globals,
        init_robot,
        function (){idx_eye_to_cal_offset = [0, 0, 0, 0, 0]},
    	find_idx_eyes,
        Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
        function(){
			let cur_eyes = JSON.parse(this.user_data.EyeNumbers)
            idx_eye_to_cal_offset = Vector.subtract([255, 255, 255, 255, 255], cur_eyes)
            
        	out("Current eyes: " + JSON.stringify(cur_eyes))
            out("idx_eye_to_cal_offset: " + JSON.stringify(idx_eye_to_cal_offset))
            
        }
        
    ]
})

new Job({
	name: "Save_Eye_Offset",
    inter_do_item_dur: 0,
    show_instructions: false,
    do_list: [
    	function(){
            let eye_offset_override = [-1, -2, -2, -1, -1]//[-2, 1, -2, -2, -2]
        
        	let eye_offset = idx_eye_to_cal_offset
            //let eye_offset = eye_offset_override
            
            eye_offset[1] = -eye_offset[1] //flip J2 ??
        	for(let i = 0; i < scan_result.length; i++){
            	scan_result[i].idx_eye_to_cal_offset = eye_offset[i]
            }
        
        	let content = JSON.stringify(scan_result)
			return Dexter.write_to_robot(content, file_on_dexter_name)
        }
    ]
})

new Job({
	name: "Cal",
    inter_do_item_dur: 0,
    show_instructions: false,
    do_list: [
    	//dde_cal
        //Dexter.set_parameter("RunFile", "Cal.make_ins")
        Dexter.set_parameter("RunFile", "CalSlow.make_ins")
        //Dexter.set_parameter("RunFile", "BootDance_IP_0.make_ins")
    ]
})

var post_cal_eyes
var post_cal_raw
var post_cal_Adc
var post_cal_rs
var post_cal_atan2
new Job({
	name: "post_cal_info",
    show_instructions: false,
	do_list: [
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
        Dexter.read_from_robot("#RawEncoders", "RawEncoders"),
        Dexter.read_from_robot("/srv/samba/share/AdcCenters.txt", "AdcCenters"),
        Dexter.empty_instruction_queue(),
        function(){
            post_cal_eyes = JSON.parse(this.user_data.EyeNumbers)
            post_cal_raw = JSON.parse(this.user_data.RawEncoders)
            post_cal_Adc = AdcCenters_string_to_array(this.user_data.AdcCenters)
            post_cal_rs = this.robot.robot_status
            post_cal_cos = [
            	post_cal_rs[Dexter.J1_A2D_COS],
                post_cal_rs[Dexter.J2_A2D_COS],
                post_cal_rs[Dexter.J3_A2D_COS],
                post_cal_rs[Dexter.J4_A2D_COS],
                post_cal_rs[Dexter.J5_A2D_COS]
            ]
            post_cal_sin = [
            	post_cal_rs[Dexter.J1_A2D_SIN],
                post_cal_rs[Dexter.J2_A2D_SIN],
                post_cal_rs[Dexter.J3_A2D_SIN],
                post_cal_rs[Dexter.J4_A2D_SIN],
                post_cal_rs[Dexter.J5_A2D_SIN]
            ]
            post_cal_PID_deltas = [
            	post_cal_rs[Dexter.J1_PID_DELTA],
                post_cal_rs[Dexter.J2_PID_DELTA],
                post_cal_rs[Dexter.J3_PID_DELTA],
                post_cal_rs[Dexter.J4_PID_DELTA],
                post_cal_rs[Dexter.J5_PID_DELTA]
            ]
            
            
            let x, y
            post_cal_atan2 = []
            for(let i = 0; i < post_cal_cos.length; i++){
            	x = post_cal_cos[i] - post_cal_Adc[i][1]
            	y = post_cal_sin[i] - post_cal_Adc[i][0]
            	post_cal_atan2.push(atan2d(x, y))
            }
            /*
            out("Eyes:")
            out(post_cal_eyes)
            out("Cos:")
            out(post_cal_cos)
            out("Sin:")
            out(post_cal_sin)
            out("atan2:")
            out(post_cal_atan2)
            */
            let obj = {
            	eyes: post_cal_eyes,
                cos: post_cal_cos,
                sin: post_cal_sin,
                atan2: post_cal_atan2,
                Adc: post_cal_Adc,
                PID_deltas: post_cal_PID_deltas
            }
            
            inspect(obj)
            return Dexter.write_to_robot(JSON.stringify(obj), file_on_dexter_name_post_cal)
            
        }
    ]
})

new Job({
	name: "Find_Idx_Eyes",
    inter_do_item_dur: idid,
    show_instructions: false,
    do_list: [
    	init_globals,
        init_robot,
    	find_idx_eyes,
        Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
        function(){
			let cur_eyes = JSON.parse(this.user_data.EyeNumbers)
            idx_eye_to_cal_offset = Vector.subtract([255, 255, 255, 255, 255], cur_eyes)
            
        	out("Current eyes: " + JSON.stringify(cur_eyes))
            out("idx_eye_to_cal_offset: " + JSON.stringify(idx_eye_to_cal_offset))
            
        },
        reset_robot,
        Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
        function(){
			let cur_eyes = JSON.parse(this.user_data.EyeNumbers)
            idx_eye_to_cal_offset = Vector.subtract([255, 255, 255, 255, 255], cur_eyes)
            
        	out("Current eyes: " + JSON.stringify(cur_eyes))
            out("idx_eye_to_cal_offset: " + JSON.stringify(idx_eye_to_cal_offset))
            
        }
    ]
})
new Job({
	name: "Find_Idx_Eyes_For_Cal",
    inter_do_item_dur: idid,
    show_instructions: false,
    do_list: [
    	init_globals,
        init_robot,
    	find_idx_eyes,
        Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
        function(){
			let cur_eyes = JSON.parse(this.user_data.EyeNumbers)
            idx_eye_to_cal_offset = Vector.subtract([255, 255, 255, 255, 255], cur_eyes)
            
        	out("Current eyes: " + JSON.stringify(cur_eyes))
            out("idx_eye_to_cal_offset: " + JSON.stringify(idx_eye_to_cal_offset))
            
        },
        reset_robot_for_cal,
        Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
        function(){
			let cur_eyes = JSON.parse(this.user_data.EyeNumbers)
            idx_eye_to_cal_offset = Vector.subtract([255, 255, 255, 255, 255], cur_eyes)
            
        	out("Current eyes: " + JSON.stringify(cur_eyes))
            out("idx_eye_to_cal_offset: " + JSON.stringify(idx_eye_to_cal_offset))
            out("Ready for cal: " )
            
        }
    ]
})


/*

new Job({
	name: "Get_PID_Deltas",
    inter_do_item_dur: 0,
    show_instructions: false,
    do_list: [
    	function(){
        	let rs = this.robot.robot_status
            let PID_Deltas = [
            	rs[Dexter.J1_PID_DELTA],
                rs[Dexter.J2_PID_DELTA],
                rs[Dexter.J3_PID_DELTA],
                rs[Dexter.J4_PID_DELTA],
                rs[Dexter.J5_PID_DELTA]
            ]
            out(JSON.stringify(PID_Deltas))
        }
    ]
})


new Job({
	name: "Move_PID",
    inter_do_item_dur: 0,
    show_instructions: false,
    do_list: [
    	//Dexter.pid_move_all_joints([-0.04416666666666667,-0.26166666666666666,0.005277777777777778,-0.21065972222222223,-0.12524305555555557])
        Dexter.pid_move_all_joints([0,0,0,0,0])
    ]
})

*/









/*
new Job({
	name: "True_Home",
    inter_do_item_dur: idid,
    show_instructions: false,
    do_list: [
    	set_found_position
    ]
})
*/

/*
var all_starting_states = [
	-3.6,
    -14.4,
    -32.4,
    -57.6,
    -90,
    -129.6,
    //-180
    5.4,
    19.8,
    41.4,
    70.2,
    106.2
]
*/


var all_starting_states = [
	90,
    66,
    48,
    30,
    18,
    10,
    4,
    0,
    -10,
    -24,
    -42,
    -64
]

/*
var all_starting_states = [
    0,
    -10,
    -24,
]
*/

/*
var all_starting_states = [
	102,
    76,
    54,
    36,
    22,
    10,
    6,
    2,
    -6,
    -18,
    -34,
    -54,
    -78
]
*/


/*
var all_starting_states = [
	5.4,
    19.8,
    41.4,
    70.2,
    106.2,
    180
]
*/


var test_results = []
/*
new Job({
	name: "Test_All_States",
    inter_do_item_dur: idid,
    show_instructions: false,
    user_data: {jnum: 1},
    do_list: [
    	Robot.loop(all_starting_states, function(iter_index, iter_val){
        	return [
    			init_globals,
                function(){
                	
                	cur_commanded_pos = [0, 0, 0, 0, 0]
                    cur_commanded_pos[this.user_data.jnum] = iter_val
                    out()
                    out("**Starting state " + iter_index + " at " + iter_val +"**")
                	
                },
        		init_robot,
    			find_idx_eyes,
        		set_found_position,
                Dexter.empty_instruction_queue(),
                Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
                Dexter.empty_instruction_queue(),
                
                function(){
                	let J = this.user_data.jnum
                	let total_time = (Date.now() - start_time)*_ms
                    let eye_number = JSON.parse(this.user_data.EyeNumbers)[this.user_data.jnum]
                    let eye_error = eye_number-255
                    final_angle_offset = cur_commanded_pos
                    let obj = {J5_cos_maxes: cos_maxes[this.user_data.jnum]}
                    test_results.push([iter_val, spacing_idx[J], final_eye_offset[J], (second_idx_eye[J] + final_eye_offset[J]), eye_number, eye_error, final_angle_offset[J], total_time, obj])
                    let found_angle = Vector.multiply(1, Vector.multiply(final_eye_offset, deg_per_eye))
                    out("State " + iter_index + " complete. Spacing: " + spacing_idx[J] + " eye_offset: " + Vector.round(final_eye_offset, 3)[J] + " eye: " + eye_number + " and angle: " + found_angle + " total_time: " + (total_time) + "s")
                },
                Dexter.empty_instruction_queue(),
                Dexter.sleep(3),
                Dexter.empty_instruction_queue()
            ]
        }),
        function(){
        	out("Test Results:")
            out("iter_val  spacing_idx  final_eye_offset  eye_number  eye_error  final_angle_offset  total_time")
            out(test_results)
        }
    ]
})
*/



/*
var Find_180_start = [0, 0, 0, 0, 0]
var Find_180_cur = [0, 0, 0, 0, 0]
var Find_180_step = [0, 0, 0, 0, 0.01]
var AdcCenters_array
new Job({
	name: "Find_180",
    inter_do_item_dur: idid,
    show_instructions: false,
    do_list: [
    	function(){
        	Find_180_cur = Find_180_start
            AdcCenters_array = AdcCenters_string_to_array(AdcCenters)
        },
    	Robot.loop(true, function(){
            let CMD = []
            CMD.push(Dexter.move_all_joints(Find_180_cur))
            CMD.push(Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"))
            
            CMD.push(Dexter.empty_instruction_queue())
            CMD.push(function(){
            	let rs = this.robot.robot_status
                let cos_val = [
                    rs[Dexter.J1_A2D_COS],
                    rs[Dexter.J2_A2D_COS],
                    rs[Dexter.J3_A2D_COS],
                    rs[Dexter.J4_A2D_COS],
                    rs[Dexter.J5_A2D_COS]
                ]
                let sin_val = [
                    rs[Dexter.J1_A2D_SIN],
                    rs[Dexter.J2_A2D_SIN],
                    rs[Dexter.J3_A2D_SIN],
                    rs[Dexter.J4_A2D_SIN],
                    rs[Dexter.J5_A2D_SIN]
                ]
				
                let x = cos_val[4] - AdcCenters_array[4][1]
                let y = sin_val[4] - AdcCenters_array[4][0]
                let atan2_val = atan2d(x, y)
                out("eye: " + this.user_data.EyeNumbers[i] + " atan2_val: " + Vector.round(atan2_val,2) + " cos: " + x + " sin: " + y)
            })
            Find_180_cur = Vector.add(Find_180_cur, Find_180_step)
            return CMD
        })
    ]
})
*/

















function do_scan(joint_num, range, step_size){
	let CMD = []
    //debugger
    let angles = [0, 0, 0, 0, 0]
    for(let theta = range[0]; theta < range[1]; theta+=step_size){
    	angles[joint_num] = theta
    	CMD.push(Dexter.move_all_joints(JSON.parse(JSON.stringify(angles))))
        CMD.push(Dexter.empty_instruction_queue())
        CMD.push(Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"))
        CMD.push(Dexter.read_from_robot("#RawEncoders", "RawEncoders"))
        CMD.push(Dexter.empty_instruction_queue())
        CMD.push(function(){
        	let rs = this.robot.rs.robot_status
            let eyes = JSON.parse(this.user_data.EyeNumbers)
            if(scan_data[joint_num].length > 0){
            	let old_eye = scan_data[joint_num][scan_data[joint_num].length-1].EyeNumber
                let diff = eyes[joint_num] - old_eye
            	if(diff < 0 || 1 < diff){
            		warning("Joint " + (joint_num + 1) + " is not calibratible. Failed at " + Vector.round(theta, 2) + " degrees. Eye: " + eyes[joint_num] + " old_Eye: " + old_eye)
            	}
            }
            let obj = {
                CmdAngle: theta,
                x: rs[Dexter["J" + (joint_num + 1) + "_A2D_COS"]],
                y: rs[Dexter["J" + (joint_num + 1) + "_A2D_SIN"]],
                EyeNumber: eyes[joint_num],
                RawEncoder: JSON.parse(this.user_data.RawEncoders)[joint_num],
                MeasuredAngle: rs[Dexter["J" + (joint_num + 1) + "_MEASURED_ANGLE"]] * _arcsec
            }
            scan_data[joint_num].push(obj)
        })
    }
    return CMD
}

function process_scan_data(scan_data){
	let elt
    let obj
    let first_eye_num, last_eye_num, old_eye_num, eye_num
    let x_vals, y_vals
    
    let x_all_data = [[], [], [], [], []]
    let y_all_data = [[], [], [], [], []]
    let x_maxes = [[], [], [], [], []]
    let y_maxes = [[], [], [], [], []]
    let result = [{}, {}, {}, {}, {}]
    for(let i = 0; i < scan_data.length; i++){
    	elt = scan_data[i]
        if(elt.length > 0){old_eye_num = elt[0].EyeNumber}
        x_vals = []
        y_vals = []
        for(let j = 0; j < elt.length; j++){
        	obj = elt[j]
            eye_num = obj.EyeNumber
            if(eye_num == old_eye_num){
            	x_vals.push(obj.x)
            	y_vals.push(obj.y)
            }else{
            	x_maxes[i].push(local_max(x_vals))
                y_maxes[i].push(local_max(y_vals))
                x_vals = []
                y_vals = []
                old_eye_num = eye_num
            }
        }
    }
    let x_second_derivative = [[], [], [], [], []]
    let y_second_derivative = [[], [], [], [], []]
    let prev, cur, next, first_derivative, sec_derivative
    for(let i = 0; i < scan_data.length; i++){
    	for(let j = 3; j < x_maxes[i].length-2; j++){
        	next = x_maxes[i][j]
            cur = x_maxes[i][j-1]
            prev = x_maxes[i][j-2]
            first_derivative = [cur - prev, next - cur]
            //sec_derivative = first_derivative[1] - first_derivative[0]
            
            //THIS MIGHT BREAK THINGS:
            if(first_derivative[0] > 0 || first_derivative[1] < 0){
            	sec_derivative = 0 // if it's not a local min it is disqualified
            }else{
            	sec_derivative = first_derivative[1] - first_derivative[0]
            }
            
            obj = {
            	val: sec_derivative,
                eye_num: scan_data[i][0].EyeNumber + j - 1
            }
            
            
            
        	x_second_derivative[i].push(obj)
        }
        for(let j = 3; j < y_maxes[i].length-2; j++){
        	next = y_maxes[i][j]
            cur = y_maxes[i][j-1]
            prev = y_maxes[i][j-2]
            first_derivative = [cur - prev, next - cur]
            sec_derivative = first_derivative[1] - first_derivative[0]
            obj = {
            	val: sec_derivative,
                eye_num: scan_data[i][0].EyeNumber + j - 1
            }
        	y_second_derivative[i].push(obj)
        }
        
        if(x_maxes[i].length > 0){
        	result[i].cos = calc_thresh(x_second_derivative[i])
        	result[i].sin = calc_thresh(y_second_derivative[i])
            result[i].sin_eye_offset = find_eye_offset(result[i].cos.idx_eye_nums, result[i].sin.idx_eye_nums)
            
            result[i].cos.maxes = x_maxes[i]
            result[i].sin.maxes = y_maxes[i]
        }
	}
    for(let i = 0; i < result.length; i++){
    	result[i].idx_eye_to_cal_offset = 0
    }
    
    return result
}

function local_max(vals){
	let max = -Infinity, elt
    for(let i = 1; i < vals.length-1; i++){
    	elt = vals[i]
    	if(vals[i] > max && 0 > ((vals[i+1] - elt) - (elt - vals[i-1]))){
        	max = elt
        }
    }
    return max
}

function calc_thresh(ddx){
	let ddx_unsorted = JSON.parse(JSON.stringify(ddx))
	ddx.sort(function(a, b){return b.val - a.val})
    let ddx_sorted = JSON.parse(JSON.stringify(ddx))
    let diff_min = Infinity
    let diff
    let val_before_drop
    let val_after_drop
    let idx_after_drop
    let buffer = 4
    for(let i = buffer; i < ddx.length-buffer; i++){
      	diff = ddx[i].val - ddx[i-1].val
      	//out(diff)
      	if(diff < diff_min){
        	val_before_drop = ddx[i-1].val
        	val_after_drop = ddx[i].val
        	idx_after_drop = i
        	diff_min = diff
      	}
    }
  	//out("val_before_drop: " + val_before_drop + " val_after_drop: " + val_after_drop + " idx_after_drop: " + idx_after_drop)
	let thresh = (val_before_drop + val_after_drop) / 2
    
  	let ddx_top = ddx.slice(0, idx_after_drop)
  	ddx_top.sort(function(a, b){return a.eye_num - b.eye_num})
  	let spacing_array = []
    let idx_eye_nums = [ddx_top[0].eye_num]
    
  	for(let i = 1; i < ddx_top.length; i++){
    	idx_eye_nums.push(ddx_top[i].eye_num)
    	spacing_array.push(ddx_top[i].eye_num - ddx_top[i - 1].eye_num)
  	}
  	//out(spacing_array)
    
    return {
    	ddx_thresh: thresh,
        num_idx_eyes: spacing_array.length + 1,
        spacing: spacing_array,
        //ddx_idx_max: Vector.max(ddx_top),
        ddx_idx_min: val_before_drop,
        ddx_non_idx_max: val_after_drop,
        idx_eye_nums: idx_eye_nums,
        ddx_unsorted: ddx_unsorted,
        ddx_sorted: ddx_sorted,
        val_before_drop: val_before_drop,
        val_after_drop: val_after_drop
    }
}


function find_eye_offset(cos_eyes, sin_eyes){
	let offset = null
    let sin_elt, cos_elt, sub
    for(let i = 1; i < cos_eyes.length; i++){
    	sin_elt = [sin_eyes[i], sin_eyes[i-1]]
        for(let j = 1; j < cos_eyes.length; j++){
        	cos_elt = [cos_eyes[j], cos_eyes[j-1]]
            sub = Vector.subtract(sin_elt, cos_elt)
            if(sub[0] == sub[1]){
            	offset = sub[0]
            }
        }
    }
    return offset
}

/*
function plot(x_data, y_data, color = "black", dim = [300, 300], title = "Plot"){
	let points = []
    if(x_data === undefined){
    	x_data = []
    	for(let i = 0; i < y_data.length; i++){
        	x_data.push(i)
        }
    }
    let lim = [Vector.max(x_data)-Vector.min(x_data), Vector.max(y_data)-Vector.min(y_data)]
    let scale = [dim[0]/lim[0], dim[1]/lim[1]]
    let center = [-scale[0]*Vector.min(x_data), -scale[1]*Vector.min(y_data)]
    for(let i = 0; i < x_data.length; i++){
    	points.push([scale[0]*x_data[i] + center[0], -(scale[1]*y_data[i]+center[1])+dim[1]])
    }

	show_window({
    content: svg_svg({id: "plot_id", height: dim[1], width: dim[0], html_class: "clickable", child_elements: 
       [svg_polyline({points: points, color: color, width: 1}),
        svg_line({x1: 0, x2: dim[0], y1: -center[1]+dim[1], y2:  -center[1]+dim[1], color: "#4f4f4f", width: 1}),
        svg_line({x1:  center[0], x2: center[0], y1: 0, y2: dim[1], color: "#4f4f4f", width: 1})
       ]}),
    title: title,
    width: 10+dim[0],
    height: 50+dim[1],
    x: 1270-(10+dim[0]),
    y: 0,
    //callback: handle1
	})
}
*/


//James N's plot:
function plot(x_data, y_data, color = "black", dim = [300, 300], title = "Plot", position = [200, 200]){
	let points = []
    if(x_data === undefined){
    	x_data = []
    	for(let i = 0; i < y_data.length; i++){
        	x_data.push(i)
        }
    }
    let lim = [Vector.max(x_data)-Vector.min(x_data), Vector.max(y_data)-Vector.min(y_data)]
    let scale = [dim[0]/lim[0], dim[1]/lim[1]]
    let center = [-scale[0]*Vector.min(x_data), -scale[1]*Vector.min(y_data)]
    for(let i = 0; i < x_data.length; i++){
    	points.push([scale[0]*x_data[i] + center[0], -(scale[1]*y_data[i]+center[1])+dim[1]])
    }
	
	show_window({
      content: svg_svg({id: title + "_id", x: position[0], y: position[1], height: dim[1], width: dim[0], html_class: "clickable", child_elements: 
         [svg_polyline({points: points, color: color, width: 1})
          //,svg_line({x1: 0, x2: dim[0], y1: -center[1]+dim[1], y2:  -center[1]+dim[1], color: "#4f4f4f", width: 1})
          //,svg_line({x1:  center[0], x2: center[0], y1: 0, y2: dim[1], color: "#4f4f4f", width: 1})
         ]}),
      title: title,
      width: 10+dim[0],
      height: 50+dim[1],
      x: 1270-(10+dim[0]),
      y: 0,
      //callback: handle1
	})
    
    //returned plot subfunction used to add points or lines. 
    //if x and y are both specified, a point is plotted.
    //if x or y is "undefined" then a line is plotted at the coordinate that is supplied.
    function plot(x_in, y_in, size=3, color="black", border="white", layer="layer1") { 
      var x = (scale[0] * x_in + center[0])
      var y = (-(scale[1] * y_in + center[1]) + dim[1])
      if (!isNaN(x) && !isNaN(y)) {
        //out("x:" + x + " y:" + y)
        append_in_ui( title+"_id",
          svg_circle({html_class: layer
            , cx: x , cy: y, r: size
            , color: color, border_color: border
            })
          )
        }
      else {
        if (isNaN(x)) {x1=0; x2=dim[0]; y1=y;y2=y;}
        if (isNaN(y)) {x1=x2=x; y1=0; y2=dim[1];}
        //out("x1:" + x1 + "y1:" + y1 + "x2:" + x2 + "y2:" + y2 )
        append_in_ui( title+"_id",
           svg_line({html_class: layer
           , x1: x1, y1: y1, x2: x2, y2: y2
           , color: color, width: size
           })
          )
        }
      }

	function trans(info, points){
        let new_points = points
        for(let i = 0; i < points.length; i++){
            new_points[i][0] = info.scale[0]*points[i][0] + info.center[0]
            new_points[i][1] = -(info.scale[1]*points[i][1]+info.center[1])+info.dim[1]
            }
        return new_points
        }
    
    //returned subfunction draws polylines between given points
    function draw(points, size=1, color="black", border="white", layer="layer1") { 
      append_in_ui(title+"_id",
		svg_polyline({html_class: layer
        , points: trans(this, points), color: color, width: size})
		)
      }
    //the layer parameter in the returned subfunction allows plotted or drawn items to be grouped, 
    //then accessed. e.g. erased for animations
    function remove_layer(layer) {
    	$("."+layer).remove()
        }
        
    let result = {scale: scale, dim: dim, center: center, plot: plot, draw: draw, remove_layer: remove_layer, trans: trans}
    return result
}


function plot_find_idx_eye_data(vals, eyes, first_eye, second_eye, jnum){
	let plot_dim = [1200, 150]
    let eye
    let eye_change = [[0, eyes[0]]]
    let x_data = []
    let y_data = []
    let data_min = Vector.min(vals)
    let data_max = Vector.max(vals)
    let old_eye = eyes[0]
    for(let i = 0; i < vals.length; i++){
        x_data.push(i)
        y_data.push(vals[i])
        
        eye = eyes[i]
        if(eye != old_eye){
        	eye_change.push([i, eye])
        }
        old_eye = eye
    }
    
    let title = "Find Idx Eye Data Plot - Joint " + (jnum+1)
    let find_idx_eye_plot = plot(undefined, y_data, "black", plot_dim, title)
    for(let i = 1; i < eye_change.length; i++){
    	eye = eye_change[i][1]
    	if(first_eye == eye || second_eye == eye){
        	let x_2 = eye_change[i][0]
            let x_1 = eye_change[i-1][0]//x_2 - 15
            let points = [
            	[x_1, data_min],
                [x_2, data_max]
            ]
            let trans_points = find_idx_eye_plot.trans(find_idx_eye_plot, points)
            let x_1_trans = trans_points[0][0]
            let x_2_trans = trans_points[1][0]
            let y_1_trans = trans_points[0][1]
            let y_2_trans = trans_points[1][1]
            let width = Math.abs(x_2_trans - x_1_trans)
            let height = Math.abs(y_2_trans - y_1_trans)
            let color
            if(first_eye == eye_change[i][1]){
            	color = "green"
            }else{
            	color = "blue"
            }
            
            append_in_ui(
            	title+"_id",
            	svg_rect({x: x_2_trans, y: y_2_trans, width: width, height: height, style: "fill-opacity:0.3;stroke-opacity:0.1", color: color})
            )
            let text_height = 6
            
            append_in_ui(
            	title+"_id",
            	svg_text({text: eye_change[i][1], x: x_2_trans, y: y_2_trans + text_height, size: text_height})
            )
        }
    }
    
    
}

function plot_scan_data(scan_data, scan_result, joint_num, eye_boxes = false){
	let plot_dim = [1200, 150]

	let obj_array = scan_data[joint_num]
    let result = scan_result[joint_num]
    let x_data = []
    let y_data = []
    let eye_change = []
    let eye
    let old_eye = obj_array[0].EyeNumber
    let cos_max = -Infinity
    let cos_min = Infinity
    let sin_max = -Infinity
    let sin_min = Infinity
    for(let i = 0; i < obj_array.length; i++){
        x_data.push(obj_array[i].x)
        y_data.push(obj_array[i].y)
        if(obj_array[i].x > cos_max){cos_max = obj_array[i].x}
        if(obj_array[i].x < cos_min){cos_min = obj_array[i].x}
        if(obj_array[i].y > sin_max){sin_max = obj_array[i].y}
        if(obj_array[i].y < sin_min){sin_min = obj_array[i].y}
        eye = obj_array[i].EyeNumber
        if(eye != old_eye){
        	eye_change.push([i, eye])
        }
        old_eye = eye
    }
    
    let title = "Joint " + (joint_num+1) + " Cos"
    let cos_plot = plot(undefined, x_data, "black", plot_dim, title)
    for(let i = 1; i < eye_change.length; i++){
    	if(result.cos.idx_eye_nums.includes(eye_change[i][1])){
        	let x_2 = eye_change[i][0]
            let x_1 = eye_change[i-1][0]//x_2 - 15
            let points = [
            	[x_1, cos_min],
                [x_2, cos_max]
            ]
            let trans_points = cos_plot.trans(cos_plot, points)
            let x_1_trans = trans_points[0][0]
            let x_2_trans = trans_points[1][0]
            let y_1_trans = trans_points[0][1]
            let y_2_trans = trans_points[1][1]
            let width = Math.abs(x_2_trans - x_1_trans)
            let height = Math.abs(y_2_trans - y_1_trans)
            
            
            
            append_in_ui(
            	title+"_id",
            	svg_rect({x: x_2_trans, y: y_2_trans, width: width, height: height, style: "fill-opacity:0.3;stroke-opacity:0.1", color: "#00ff00"})
            )
            let text_height = 6
            
            append_in_ui(
            	title+"_id",
            	svg_text({text: eye_change[i][1], x: x_2_trans, y: y_2_trans + text_height, size: text_height})
            )
            out(i + ": eye_change: " + (eye_change[i][1]-1) + " x_1_trans: " + x_1_trans + " y_ave: " + (y_1_trans + y_2_trans)/2)
        }else if(eye_boxes){
        	let x_2 = eye_change[i][0]
            let x_1 = eye_change[i-1][0]//x_2 - 15
            let points = [
            	[x_1, cos_min],
                [x_2, cos_max]
            ]
            let trans_points = cos_plot.trans(cos_plot, points)
            let x_1_trans = trans_points[0][0]
            let x_2_trans = trans_points[1][0]
            let y_1_trans = trans_points[0][1]
            let y_2_trans = trans_points[1][1]
            let width = Math.abs(x_2_trans - x_1_trans)
            let height = Math.abs(y_2_trans - y_1_trans)
            
            
            
            append_in_ui(
            	title+"_id",
            	svg_rect({x: x_2_trans, y: y_2_trans, width: width, height: height, style: "fill-opacity:0;stroke-opacity:0.5", color: "#0000ff"})
            )
            let text_height = 6
            
            append_in_ui(
            	title+"_id",
            	svg_text({text: eye_change[i][1], x: x_2_trans, y: y_2_trans + text_height, size: text_height})
            )
        }
    }
    
    
    /*
    title = "Joint " + (joint_num+1) + " Sin"
    let sin_plot = plot(undefined, y_data, "black", plot_dim, title, [200, 550])
    for(let i = 1; i < eye_change.length; i++){
    	if(result.sin.idx_eye_nums.includes(eye_change[i][1])){
        	let x_2 = eye_change[i][0]
            let x_1 = eye_change[i-1][0] //x_2 - 15
            let points = [
            	[x_1, cos_min],
                [x_2, cos_max]
            ]
            let trans_points = cos_plot.trans(cos_plot, points)
            let x_1_trans = trans_points[0][0]
            let x_2_trans = trans_points[1][0]
            let y_1_trans = trans_points[0][1]
            let y_2_trans = trans_points[1][1]
            let width = Math.abs(x_2_trans - x_1_trans)
            let height = Math.abs(y_2_trans - y_1_trans)
            
            append_in_ui(
            	title+"_id",
            	svg_rect({x: x_2_trans, y: y_2_trans, width: width, height: height, style: "fill-opacity:0.3;stroke-opacity:0.1", color: "#00ff00"})
            )
      	}
    }
    */
    
    let cos_ddx_unsorted = []
    let cos_ddx_sorted = []
    let sin_ddx_unsorted = []
    let sin_ddx_sorted = []
    for(let i = 0; i < result.cos.ddx_unsorted.length; i++){
    	cos_ddx_unsorted.push(result.cos.ddx_unsorted[i].val)
        cos_ddx_sorted.push(result.cos.ddx_sorted[i].val)
        sin_ddx_unsorted.push(result.sin.ddx_unsorted[i].val)
        sin_ddx_sorted.push(result.sin.ddx_sorted[i].val)
    }
    
    title = "Joint " + (joint_num+1) + " Cos Local Maxima"
    let cos_maxes_plot = plot(undefined, result.cos.maxes, "black", plot_dim, title, [200, 550])
    //cos_plot.draw(copy(result.cos.maxes), 1, "red")
    
    title = "Joint " + (joint_num+1) + " Cos ddx Unsorted"
    let cos_ddx_unsorted_plot = plot(undefined, cos_ddx_unsorted, "black", plot_dim, title, [200, 550])
    title = "Joint " + (joint_num+1) + " Cos ddx Sorted"
    let cos_ddx_sorted_plot = plot(undefined, cos_ddx_sorted, "black", plot_dim, title, [200, 550])
    
    points = [
    	[0, result.cos.ddx_thresh],
        [cos_ddx_unsorted.length, result.cos.ddx_thresh],
    ]
    cos_ddx_unsorted_plot.draw(copy(points), undefined, "red")
    cos_ddx_sorted_plot.draw(copy(points), undefined, "red")
    
    points = [
    	[0, result.cos.val_before_drop],
        [cos_ddx_unsorted.length, result.cos.val_before_drop],
    ]
    cos_ddx_unsorted_plot.draw(copy(points), undefined, "blue")
    cos_ddx_sorted_plot.draw(copy(points), undefined, "blue")
    
    points = [
    	[0, result.cos.val_after_drop],
        [cos_ddx_unsorted.length, result.cos.val_after_drop],
    ]
    
    cos_ddx_sorted_plot.draw(copy(points), undefined, "green")
    cos_ddx_unsorted_plot.draw(copy(points), undefined, "green")
    
    
    
}

function copy(variable){
	return JSON.parse(JSON.stringify(variable))
}


/*

J1:
[192,200,206,210,212,215,220,227,236,247]
[187,197,205,211,215,217,220,225,232,241]

J2:
[222,233,242,249,254,257,259,263,269,277]
[218,229,238,245,250,253,255,259,265,273]


Vector.subtract(
	[192,200,206,210,212,215,220,227,236, 247],
	[187, 197,205,211,215,217,220,225,232,241]
)


*/

/*
var fp = choose_file()
var scan_data = JSON.parse(file_content(fp))

var ddx = process_scan_data(scan_data)
ddx[0].sort(function(a, b){return b.val - a.val})
var diff_min = Infinity
var diff
var val_before_drop
var val_after_drop
var idx_after_drop
for(let i = 1; i < ddx[0].length; i++){
	diff = ddx[0][i].val - ddx[0][i-1].val
    out(diff)
    if(diff < diff_min){
    	val_before_drop = ddx[0][i-1].val
        val_after_drop = ddx[0][i].val
        idx_after_drop = if
    	diff_min = diff
    }
}
out("val_before_drop: " + val_before_drop + " val_after_drop: " + val_after_drop + " idx_after_drop: " + idx_after_drop)

var ddx_top = ddx[0].slice(0, idx_after_drop)
ddx_top.sort(function(a, b){return a.eye_num - b.eye_num})
var spacing_array = []
for(let i = 1; i < ddx_top.length; i++){
	spacing_array.push(ddx_top[i].eye_num - ddx_top[i - 1].eye_num)
}
out(spacing_array)
*/



//MOVED ABOVE Find_Idx_Eyes Job
/*
new Job({
	name: "Initial_Scan",
    inter_do_item_dur: idid,
    show_instructions: false,
    do_list: [
    	
    	function(){scan_data = [[], [], [], [], []]},
        init_globals,
        init_robot,
        
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[0] = []},
    	function(){return do_scan(0, [-180, 180], 360/n_eyes[0] / 15)},

		Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[1] = []},
        function(){return do_scan(1, [-100, 100], 360/n_eyes[1] / 15)},
	
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[2] = []},
        function(){return do_scan(2, [-135, 135], 360/n_eyes[2] / 15)},
        
        
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[3] = []},
        function(){return do_scan(3, [-95, 95], 360/n_eyes[3] / 15)},
        
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        function(){scan_data[4] = []},
        function(){return do_scan(4, [-150, 150], 360/n_eyes[4] / 15)},
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
     
        function(){
        	scan_result = process_scan_data(scan_data)
            inspect(scan_result)
            
            for(let i = 0; i < 3; i++){
            	plot_scan_data(scan_data, scan_result, i)
            }
            
        }
	]
})
*/


/*
[164,172,178,182,184,187,192,199,208,219]
[159,169,177,183,187,189,192,197,204,213]
*/


/*
var backup_data = JSON.parse(JSON.stringify(scan_data))

choose_save_file()
var fp = "C:\\Users\\james\\Documents\\dde_apps\\2019\\_Code\\Misc\\EncoderIdeas\\backup_data.json"
write_file(fp, JSON.stringify(backup_data))


scan_data = JSON.parse(file_content(fp))
*/

/*
var R = 26.6519962050703718
var C = (R*2*Math.PI)
var open_width = 0.8
var open_angle = open_width / C * 360
var N = 120
var close_angle = (360 - open_angle*N) / (N-1)
var close_width = close_angle / 360 * C
out("close angle: " + close_angle + " close_width: " + close_width)


*/

/*
var found_angles
new Job({
	name: "current_angles",
    do_list: [
    	function(){
        	let rs = Dexter.dexter0.robot_status
        	found_angles = [
            	rs[Dexter.J1_ANGLE],
                rs[Dexter.J2_ANGLE],
                rs[Dexter.J3_ANGLE],
                rs[Dexter.J4_ANGLE],
                rs[Dexter.J5_ANGLE]
            ]
            out(found_angles)
        }
    ]
})
*/


/*
plot_scan_data(scan_data, scan_result, 4)
*/
//idx home = [228, 252, 256, 255, 253]
//post cal = [256, 255, 255, 256, 256]
/*
post_cal_atan2 = [
-119.0219445285047,
-14.939912678614727,
-22.149429442440223,
-4.331826043929831
]


Dexter.set_parameter("CommandedAngles", 0, 0, 0, 0, 0),
        Dexter.set_parameter("EyeNumbers", 255, 255, 255, 255, 255)
*/


new Job({
	name: "J1pos",
    show_instructions: false,
    user_data: {joint: 0},
	do_list: [
    	function(){
        	let cur = [
            	this.robot.robot_status[Dexter.J1_ANGLE],
                this.robot.robot_status[Dexter.J2_ANGLE],
                this.robot.robot_status[Dexter.J3_ANGLE],
                this.robot.robot_status[Dexter.J4_ANGLE],
                this.robot.robot_status[Dexter.J5_ANGLE]
            ]
            cur[this.user_data.joint] += deg_per_eye[this.user_data.joint]
            out(cur)
        	return Dexter.move_all_joints(cur)
        },
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
		Dexter.empty_instruction_queue(),
        function(){
        	out("J" + (1+this.user_data.joint) + " Eye: " + JSON.parse(this.user_data.EyeNumbers)[this.user_data.joint])
        }
    ]
})

new Job({
	name: "J1neg",
    show_instructions: false,
    user_data: {joint: 0},
	do_list: [
    	function(){
        	let cur = [
            	this.robot.robot_status[Dexter.J1_ANGLE],
                this.robot.robot_status[Dexter.J2_ANGLE],
                this.robot.robot_status[Dexter.J3_ANGLE],
                this.robot.robot_status[Dexter.J4_ANGLE],
                this.robot.robot_status[Dexter.J5_ANGLE]
            ]
            cur[this.user_data.joint] -= deg_per_eye[this.user_data.joint]
            out(cur)
        	return Dexter.move_all_joints(cur)
        },
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
		Dexter.empty_instruction_queue(),
        function(){
        	out("J" + (1+this.user_data.joint) + " Eye: " + JSON.parse(this.user_data.EyeNumbers)[this.user_data.joint])
        }
    ]
})

new Job({
	name: "J2pos",
    show_instructions: false,
    user_data: {joint: 1},
	do_list: [
    	function(){
        	let cur = [
            	this.robot.robot_status[Dexter.J1_ANGLE],
                this.robot.robot_status[Dexter.J2_ANGLE],
                this.robot.robot_status[Dexter.J3_ANGLE],
                this.robot.robot_status[Dexter.J4_ANGLE],
                this.robot.robot_status[Dexter.J5_ANGLE]
            ]
            cur[this.user_data.joint] += deg_per_eye[this.user_data.joint]
            out(cur)
        	return Dexter.move_all_joints(cur)
        },
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
		Dexter.empty_instruction_queue(),
        function(){
        	out("J" + (1+this.user_data.joint) + " Eye: " + JSON.parse(this.user_data.EyeNumbers)[this.user_data.joint])
        }
    ]
})

new Job({
	name: "J2neg",
    show_instructions: false,
    user_data: {joint: 1},
	do_list: [
    	function(){
        	let cur = [
            	this.robot.robot_status[Dexter.J1_ANGLE],
                this.robot.robot_status[Dexter.J2_ANGLE],
                this.robot.robot_status[Dexter.J3_ANGLE],
                this.robot.robot_status[Dexter.J4_ANGLE],
                this.robot.robot_status[Dexter.J5_ANGLE]
            ]
            cur[this.user_data.joint] -= deg_per_eye[this.user_data.joint]
            out(cur)
        	return Dexter.move_all_joints(cur)
        },
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
		Dexter.empty_instruction_queue(),
        function(){
        	out("J" + (1+this.user_data.joint) + " Eye: " + JSON.parse(this.user_data.EyeNumbers)[this.user_data.joint])
        }
    ]
})

new Job({
	name: "J3pos",
    show_instructions: false,
    user_data: {joint: 2},
	do_list: [
    	function(){
        	let cur = [
            	this.robot.robot_status[Dexter.J1_ANGLE],
                this.robot.robot_status[Dexter.J2_ANGLE],
                this.robot.robot_status[Dexter.J3_ANGLE],
                this.robot.robot_status[Dexter.J4_ANGLE],
                this.robot.robot_status[Dexter.J5_ANGLE]
            ]
            cur[this.user_data.joint] += deg_per_eye[this.user_data.joint]
            out(cur)
        	return Dexter.move_all_joints(cur)
        },
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
		Dexter.empty_instruction_queue(),
        function(){
        	out("J" + (1+this.user_data.joint) + " Eye: " + JSON.parse(this.user_data.EyeNumbers)[this.user_data.joint])
        }
    ]
})

new Job({
	name: "J3neg",
    show_instructions: false,
    user_data: {joint: 2},
	do_list: [
    	function(){
        	let cur = [
            	this.robot.robot_status[Dexter.J1_ANGLE],
                this.robot.robot_status[Dexter.J2_ANGLE],
                this.robot.robot_status[Dexter.J3_ANGLE],
                this.robot.robot_status[Dexter.J4_ANGLE],
                this.robot.robot_status[Dexter.J5_ANGLE]
            ]
            cur[this.user_data.joint] -= deg_per_eye[this.user_data.joint]
            out(cur)
        	return Dexter.move_all_joints(cur)
        },
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
		Dexter.empty_instruction_queue(),
        function(){
        	out("J" + (1+this.user_data.joint) + " Eye: " + JSON.parse(this.user_data.EyeNumbers)[this.user_data.joint])
        }
    ]
})

new Job({
	name: "J4pos",
    show_instructions: false,
    user_data: {joint: 3},
	do_list: [
    	function(){
        	let cur = [
            	this.robot.robot_status[Dexter.J1_ANGLE],
                this.robot.robot_status[Dexter.J2_ANGLE],
                this.robot.robot_status[Dexter.J3_ANGLE],
                this.robot.robot_status[Dexter.J4_ANGLE],
                this.robot.robot_status[Dexter.J5_ANGLE]
            ]
            cur[this.user_data.joint] += deg_per_eye[this.user_data.joint]
            out(cur)
        	return Dexter.move_all_joints(cur)
        },
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
		Dexter.empty_instruction_queue(),
        function(){
        	out("J" + (1+this.user_data.joint) + " Eye: " + JSON.parse(this.user_data.EyeNumbers)[this.user_data.joint])
        }
    ]
})

new Job({
	name: "J4neg",
    show_instructions: false,
    user_data: {joint: 3},
	do_list: [
    	function(){
        	let cur = [
            	this.robot.robot_status[Dexter.J1_ANGLE],
                this.robot.robot_status[Dexter.J2_ANGLE],
                this.robot.robot_status[Dexter.J3_ANGLE],
                this.robot.robot_status[Dexter.J4_ANGLE],
                this.robot.robot_status[Dexter.J5_ANGLE]
            ]
            cur[this.user_data.joint] -= deg_per_eye[this.user_data.joint]
            out(cur)
        	return Dexter.move_all_joints(cur)
        },
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
		Dexter.empty_instruction_queue(),
        function(){
        	out("J" + (1+this.user_data.joint) + " Eye: " + JSON.parse(this.user_data.EyeNumbers)[this.user_data.joint])
        }
    ]
})

new Job({
	name: "J5pos",
    show_instructions: false,
    user_data: {joint: 4},
	do_list: [
    	function(){
        	let cur = [
            	this.robot.robot_status[Dexter.J1_ANGLE],
                this.robot.robot_status[Dexter.J2_ANGLE],
                this.robot.robot_status[Dexter.J3_ANGLE],
                this.robot.robot_status[Dexter.J4_ANGLE],
                this.robot.robot_status[Dexter.J5_ANGLE]
            ]
            cur[this.user_data.joint] += deg_per_eye[this.user_data.joint]
            out(cur)
        	return Dexter.move_all_joints(cur)
        },
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
		Dexter.empty_instruction_queue(),
        function(){
        	out("J" + (1+this.user_data.joint) + " Eye: " + JSON.parse(this.user_data.EyeNumbers)[this.user_data.joint])
        }
    ]
})

new Job({
	name: "J5neg",
    show_instructions: false,
    user_data: {joint: 4},
	do_list: [
    	function(){
        	let cur = [
            	this.robot.robot_status[Dexter.J1_ANGLE],
                this.robot.robot_status[Dexter.J2_ANGLE],
                this.robot.robot_status[Dexter.J3_ANGLE],
                this.robot.robot_status[Dexter.J4_ANGLE],
                this.robot.robot_status[Dexter.J5_ANGLE]
            ]
            cur[this.user_data.joint] -= deg_per_eye[this.user_data.joint]
            out(cur)
        	return Dexter.move_all_joints(cur)
        },
        Dexter.empty_instruction_queue(),
    	Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"),
		Dexter.empty_instruction_queue(),
        function(){
        	out("J" + (1+this.user_data.joint) + " Eye: " + JSON.parse(this.user_data.EyeNumbers)[this.user_data.joint])
        }
    ]
})



var FPGA = {
	BASE_POSITION: 0,
    END_POSITION: 1,
    PIVOT_POSITION: 2,
    ANGLE_POSITON: 3,
    ROT_POSITION: 4,
    ACCELERATION_MAXSPEED: 5,
    BASE_SIN_CENTER: 6,
    BASE_COS_CENTER: 7,
    END_SIN_CENTER: 8,
    END_COS_CENTER: 9,
    PIVOT_SIN_CENTER: 10,
    PIVOT_COS_CENTER: 11,
    ANGLE_SIN_CENTER: 12,
    ANGLE_COS_CENTER: 13,
    ROT_SIN_CENTER: 14,
    ROT_COS_CENTER: 15,
    PID_DELTATNOT: 16,
    PID_DELTAT: 17,
    PID_D: 18,
    PID_I: 19,
    PID_P: 20,
    PID_ADDRESS: 21,
    BOUNDRY_BASE: 22,
    BOUNDRY_END: 23,
    BOUNDRY_PIVOT: 24,
    BOUNDRY_ANGLE: 25,
    BOUNDRY_ROT: 26,
    SPEED_FACTORA: 27,
    SPEED_FACTORB: 28,
    FRICTION_BASE: 29,
    FRICTION_END: 30,
    FRICTION_PIVOT: 31,
    FRICTION_ANGLE: 32,
    FRICTION_ROT: 33,
    MOVE_TRHESHOLD: 34,
    F_FACTOR: 35,
    MAX_ERROR: 36,
    FORCE_BIAS_BASE: 37,
    FORCE_BIAS_END: 38,
    FORCE_BIAS_PIVOT: 39,
    FORCE_BIAS_ANGLE: 40,
    FORCE_BIAS_ROT: 41,
    COMMAND_REG: 42,
    DMA_CONTROL: 43,
    DMA_WRITE_DATA: 44,
    DMA_WRITE_PARAMS: 45,
    DMA_WRITE_ADDRESS: 46,
    DMA_READ_PARAMS: 47,
    DMA_READ_ADDRESS: 48,
    REC_PLAY_CMD: 49,
    REC_PLAY_TIMEBASE: 50,
    DIFF_FORCE_TIMEBASE: 51,
    DIFF_FORCE_BETA: 52,
    DIFF_FORCE_MOVE_THRESHOLD: 53,
    DIFF_FORCE_MAX_SPEED: 54,
    DIFF_FORCE_SPEED_FACTOR_ANGLE: 55,
    DIFF_FORCE_SPEED_FACTOR_ROT: 56,
    DIFF_FORCE_ANGLE_COMPENSATE: 57,
    FINE_ADJUST_BASE: 58,
    FINE_ADJUST_END: 59,
    FINE_ADJUST_PIVOT: 60,
    FINE_ADJUST_ANGLE: 61,
    FINE_ADJUST_ROT: 62,
    RECORD_LENGTH: 63,
    END_EFFECTOR_IO: 64,
    SERVO_SETPOINT_A: 65,
    SERVO_SETPOINT_B: 66,
    BASE_FORCE_DECAY: 67,
    END_FORCE_DECAY: 68,
    PIVOT_FORCE_DECAY: 69,
    ANGLE_FORCE_DECAY: 70,
    ROTATE_FORCE_DECAY: 71,
    PID_SCHEDULE_INDEX: 72,
    GRIPPER_MOTOR_CONTROL: 73,
    GRIPPER_MOTOR_OFF_WIDTH: 74,
    GRIPPER_MOTOR_ON_WIDTH: 75,
    START_SPEED: 76,
    ANGLE_END_RATIO: 77,
    CMD2: 78,
    PID_TIMEBASE: 79,
    PHYSICS_XYZ_TIMEBASE: 80,
    PHYSICS_DIFF_TIMEBASE: 81
}

FPGA.cmd_reg_val = function({
	CapCalibrateBase = false,
    CapCalibrateEnd = false,
    CapCalibratePivot = false,
    MoveEnable = false,
    GoMove = false,
    EnableLoop = false,
    AClrLoop = false,
    CAL_RUN = false,
    ResetMotorPosition = false,
    ResetForce = false,
    CapCalAngle = false,
    CapCalRot = false,
    AngleEnable = false,
    RotEnable = false,
}={}){
	let result = 0
    if(CapCalibrateBase){   result += 1}
    if(CapCalibrateEnd){    result += 2}
    if(CapCalibratePivot){  result += 4}
    if(MoveEnable){         result += 8}
    if(GoMove){             result += 16}
    if(EnableLoop){         result += 32}
    if(AClrLoop){           result += 64}
    if(CAL_RUN){            result += 128}
    if(ResetMotorPosition){ result += 256}
    if(ResetForce){         result += 512}
    if(CapCalAngle){        result += 1024}
    if(CapCalRot){          result += 2048}
    if(AngleEnable){        result += 4096}
    if(RotEnable){          result += 8192}
    return result
}

FPGA.cmd_reg_val({
	EnableLoop: true,
    CAL_RUN: true,
    ResetForce: true,
    AngleEnable: true,
    RotEnable: true
})

function reset_robot(){
	return [
    	make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val({
        	AClrLoop: true,
            ResetMotorPosition: true,
            ResetForce:true
        })),
        make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val()),
        
        make_ins('w', FPGA.CMD2, 7),
        make_ins('w', FPGA.CMD2, 0),
        
        make_ins('w', FPGA.PID_TIMEBASE, 86),
        make_ins('w', FPGA.PID_TIMEBASE, 86),
        make_ins('w', FPGA.PHYSICS_XYZ_TIMEBASE, 86),
        make_ins('w', FPGA.PHYSICS_DIFF_TIMEBASE, 172),
        
        make_ins('w', FPGA.DIFF_FORCE_BETA, 177),
        make_ins('w', FPGA.SPEED_FACTORB, 90),
		
        Dexter.sleep(0.5),
        Dexter.set_parameter("MaxSpeed", 30),
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        Dexter.move_all_joints([6, 6, 6, 6, 6]),
        Dexter.move_all_joints([0, 0, 0, 0, 0]),
        
        Dexter.empty_instruction_queue(),
        
        make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val({
			EnableLoop: true,
    		CAL_RUN: true,
    		ResetForce: true,
    		AngleEnable: true,
    		RotEnable: true
		})),
        //make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val()),
        
        Dexter.set_parameter("J1BoundryLow", -150),
        Dexter.set_parameter("J1BoundryHigh", 150),
        Dexter.set_parameter("J2BoundryLow", -90),
        Dexter.set_parameter("J2BoundryHigh", 90),
        Dexter.set_parameter("J3BoundryLow", -150),
        Dexter.set_parameter("J3BoundryHigh", 150),
        Dexter.set_parameter("J4BoundryLow", -90),
        Dexter.set_parameter("J4BoundryHigh", 90),
        Dexter.set_parameter("J5BoundryLow", -140),
        Dexter.set_parameter("J5BoundryHigh", 140),
        
        Dexter.sleep(0.5),
        Dexter.set_keep_position(),
    ]
}
function reset_robot_for_cal(){
	return [
    	make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val({
        	AClrLoop: true,
            ResetMotorPosition: true,
            ResetForce:true
        })),
        make_ins('w', FPGA.COMMAND_REG, FPGA.cmd_reg_val()),
        
        make_ins('w', FPGA.CMD2, 7),
        make_ins('w', FPGA.CMD2, 0),
        
        make_ins('w', FPGA.PID_TIMEBASE, 86),
        make_ins('w', FPGA.PID_TIMEBASE, 86),
        make_ins('w', FPGA.PHYSICS_XYZ_TIMEBASE, 86),
        make_ins('w', FPGA.PHYSICS_DIFF_TIMEBASE, 172),
        
        make_ins('w', FPGA.DIFF_FORCE_BETA, 177),
        make_ins('w', FPGA.SPEED_FACTORB, 90)
		
    ]
}

/*
new Job({
	name: "Reset_Robot",
    do_list: [
    	reset_robot
    ]
})
*/

/*
new Job({
	name: "Set_Boundaries",
    do_list: [
		Dexter.set_parameter("J1BoundryLow", -150),
        Dexter.set_parameter("J1BoundryHigh", 150),
        Dexter.set_parameter("J2BoundryLow", -90),
        Dexter.set_parameter("J2BoundryHigh", 90),
        Dexter.set_parameter("J3BoundryLow", -150),
        Dexter.set_parameter("J3BoundryHigh", 150),
        Dexter.set_parameter("J4BoundryLow", -90),
        Dexter.set_parameter("J4BoundryHigh", 90),
        Dexter.set_parameter("J5BoundryLow", -140),
        Dexter.set_parameter("J5BoundryHigh", 140)
    ]
})
*/
/*
var oldEye = scan_data[1][0].EyeNumber
var oldAngle = scan_data[1][0].CmdAngle
var angles = []
for(let i = 0; i < scan_data[1].length; i++){
	if(scan_data[1][i].EyeNumber != oldEye){
    	out(scan_data[1][i].CmdAngle - oldAngle)
        oldAngle = scan_data[1][i].CmdAngle
        oldEye = scan_data[1][i].EyeNumber
    }
}
*/


var atan2_vals, atan2_goal, J_error_thres, E_error_thresh, J_error
/*
new Job({
	name: "Center_Eye",
    inter_do_item_dur: 0.01,
    show_instructions: false,
    do_list: [
    	function(){
        	J_error_thres = [2*_arcsec, 2*_arcsec, 2*_arcsec, 20*_arcsec, 20*_arcsec]
            
        	atan2_vals = [Infinity, Infinity, Infinity, Infinity, Infinity]
            atan2_goal = [0, 0, 0, 0, 0]
            J_error = [Infinity, Infinity, Infinity, Infinity, Infinity]
            E_error_thresh = Vector.divide(Vector.multiply(360, J_error_thres), deg_per_eye)
        },
    	Robot.loop(
        	function(){
            
            	let result = false
                for(let i = 0; i < atan2_vals.length; i++){
                	if(!(Math.abs(J_error[i]) < J_error_thres[i])){
                    	result = true
                    }
                }
                return result
            },
            function(){
            	let CMD = []
                CMD.push(Dexter.read_from_robot("#EyeNumbers", "EyeNumbers"))
                CMD.push(function(){EyeNumber = JSON.parse(this.user_data.EyeNumbers)}),
                CMD.push(Dexter.get_robot_status())
                CMD.push(function(){
                	let rs = this.robot.robot_status
            		let cos_val = [
            			rs[Dexter.J1_A2D_COS],
                		rs[Dexter.J2_A2D_COS],
                		rs[Dexter.J3_A2D_COS],
                		rs[Dexter.J4_A2D_COS],
                		rs[Dexter.J5_A2D_COS]
            		]
            		let sin_val = [
            			rs[Dexter.J1_A2D_SIN],
                		rs[Dexter.J2_A2D_SIN],
                		rs[Dexter.J3_A2D_SIN],
                		rs[Dexter.J4_A2D_SIN],
                		rs[Dexter.J5_A2D_SIN]
            		]
                    let cur_angles = [
            			rs[Dexter.J1_ANGLE],
                		rs[Dexter.J2_ANGLE],
                		rs[Dexter.J3_ANGLE],
                		rs[Dexter.J4_ANGLE],
                		rs[Dexter.J5_ANGLE]
            		]
                    
                    let x, y
                    let step = [0, 0, 0, 0, 0]
                    let str = ""
                    for(let i = 0; i < 5; i++){
            			x = cos_val[i] - AdcCenters_array[i][1]
                		y = sin_val[i] - AdcCenters_array[i][0]
                		atan2_vals[i] = atan2d(x, y)
                        atan2_error = atan2_goal[i] - atan2_vals[i]
                        J_error[i] = atan2_error * deg_per_eye[i] / 360
                        step[i] = J_error[i]
                        //str += "| " + EyeNumber[i] + ", " + Vector.round(atan2_error, 3) + ", " + Math.round(J_error[i]/_arcsec) + " "
                    	str += "| " + EyeNumber[i] + ", " + Math.round(J_error[i]/_arcsec) + " "
                    }
                    out(str, "blue")
                    return Dexter.move_all_joints(Vector.add(cur_angles, step))
                })
                CMD.push(Dexter.empty_instruction_queue())
                
                return CMD
            }
        )
    ]
})    
*/
/*
var PID_deltas
new Job({
	name: "PID_Deltas",
    inter_do_item_dur: 0.01,
    show_instructions: false,
    do_list: [
    	function(){
        	rs = this.robot.robot_status
            PID_deltas = [
            	rs[Dexter.J1_PID_DELTA],
                rs[Dexter.J2_PID_DELTA],
                rs[Dexter.J3_PID_DELTA],
                rs[Dexter.J4_PID_DELTA],
                rs[Dexter.J5_PID_DELTA]
            ]
            
            out(PID_deltas)
        }
    ]
})

new Job({
	name: "PID_move_by_Deltas",
    inter_do_item_dur: 0.01,
    show_instructions: false,
    do_list: [
    	function(){if(!PID_deltas){dde_error("PID_deltas is undefined. Run PID_Deltas Job.")}},
    	Dexter.pid_move_all_joints(Vector.multiply(1, PID_deltas))
    ]
})



*/



function dde_cal(){
	return [
		make_ins("w", 42,64),
		make_ins("w", 42,0),
		make_ins("w", 42,256),
		make_ins("w", 42,0),
		make_ins("w", 79, 50 ^ 200 ),
		make_ins("w", 80, 50 ^ 200 ),
		make_ins("w", 81, 50 ^ 200 ),
		make_ins("S", "J1BoundryHigh",670010 * _arcsec),
		make_ins("S", "J1BoundryLow",-670010 * _arcsec),
		make_ins("S", "J2BoundryLow",-350010 * _arcsec),
		make_ins("S", "J2BoundryHigh",350010 * _arcsec),
		make_ins("S", "J3BoundryLow",-570010 * _arcsec),
		make_ins("S", "J3BoundryHigh",570010 * _arcsec),
		make_ins("S", "J4BoundryLow",-390010 * _arcsec),
		make_ins("S", "J4BoundryHigh",390010 * _arcsec),
		make_ins("S", "J5BoundryLow",-680010 * _arcsec),
		make_ins("S", "J5BoundryHigh",680010 * _arcsec),
        make_ins("S", "MaxSpeed", 240000 / _nbits_cf),
    		  
		make_ins("a", ...[670000,0,0,0,0].arcsec()),
		make_ins("F"),
		make_ins("w", 42,1),
		make_ins("a", ...[-670000,0,0,0,0].arcsec()),
		make_ins("F"),
		make_ins("w", 42,0),
              
		make_ins("a", ...[0,0,0,0,0].arcsec()),
		make_ins("a", ...[0,350000,0,0,0].arcsec()),
		make_ins("F"),
		make_ins("w", 42,4),
		make_ins("a", ...[0,-350000,0,0,0].arcsec()),
		make_ins("F"),
		make_ins("w", 42,0),
              
		make_ins("a", ...[0,0,0,0,0].arcsec()),
		make_ins("a", ...[0,0,570000,0,0].arcsec()),
		make_ins("F"),
		make_ins("w", 42,2),
		make_ins("a", ...[0,0,-570000,0,0].arcsec()),
		make_ins("F"),
		make_ins("w", 42,0),
              
		make_ins("a", ...[0,0,0,0,0].arcsec()),
		//make_ins("S", "MaxSpeed", 80000 / _nbits_cf),
		make_ins("a", ...[0,0,0,370000,0].arcsec()),
		make_ins("F"),
		make_ins("w", 42,1024),
		make_ins("a", ...[0,0,0,-370000,0].arcsec()),
		make_ins("F"),
		make_ins("w", 42,0),
		make_ins("a", ...[0,0,0,0,680000].arcsec()),
		make_ins("F"),
		make_ins("w", 42,2048),
              
		make_ins("a", ...[0,0,0,0,-680000].arcsec()),
		make_ins("F"),
		make_ins("w", 42,0),
              
		make_ins("a", ...[0,0,0,0,0].arcsec()),
		make_ins("S", "MaxSpeed", 240000 / _nbits_cf),
		make_ins("a", ...[100000,100000,100000,100000,100000].arcsec()),
		make_ins("a", ...[0,0,0,0,0].arcsec()),
		make_ins("F"),
              
		make_ins("w", 42,64),
		make_ins("w", 42,0),
		make_ins("w", 42,256),
		make_ins("w", 42,0),
		make_ins("l"),
              
		make_ins("S", "J1BoundryHigh",648000 * _arcsec),
		make_ins("S", "J1BoundryLow",-648000 * _arcsec),
		make_ins("S", "J2BoundryLow",-300000 * _arcsec),
		make_ins("S", "J2BoundryHigh",300000 * _arcsec),
		make_ins("S", "J3BoundryLow",-530000 * _arcsec),
		make_ins("S", "J3BoundryHigh",530000 * _arcsec),
		make_ins("S", "J4BoundryLow",-340000 * _arcsec),
		make_ins("S", "J4BoundryHigh",340000 * _arcsec),
		make_ins("S", "J5BoundryLow",-648000 * _arcsec),
		make_ins("S", "J5BoundryHigh",648000 * _arcsec),
              
		Dexter.sleep(1),
		make_ins("w", 42,12960),
    ]
}


var AA_time_stamp
var A_dde_apps_dir
new Human({name: "my_human"})
new Job({
	name: "Save_Bug_Report",
    show_instructions: false,
    keep_history: false,
    robot: Human.my_human,
    do_list: [
    	function(){
        	var d = new Date();
			AA_time_stamp = d.toString();
            A_dde_apps_dir = dde_apps_dir
        
        	let var_list = [
            	"prev_eye_cos_vals",
            	"prev_eye_sin_vals",
            	"cur_commanded_pos",
            	"cos_maxes",
            	"sin_maxes",
            	"cur_direction",
            	"first_idx_eye",
            	"second_idx_eye",
            	"spacing_to_eye_offset",
            	"final_eye_offset",
            	"cos_to_center_block_offset",
            	"spacing_idx",
            	"final_angle_offset",
            	"stage_idx",
            	"stage_string_array",
            	"true_home_eye",
            	"neg_spacing_to_eye_offset",
            	"pos_spacing_to_eye_offset",
            	"all_cos_vals",
            	"all_sin_vals",
            	"all_eyes",

            	"scan_data",
            	"scan_result",
            	"cos_diff_thres",
            	"sin_diff_thres",
            	"eyes_between_sensors",
            	"info_raw_idx_eye",
            	"info_post_calibration",
            	"idx_eye_to_cal_offset",
            	"EyeNumber",
            	"waiting_eyes",
            	"all_waiting",
            	"idx_eye_to_cal_offset",
            	"post_cal_info",
                
                "AA_time_stamp",
                "A_dde_apps_dir"
            ]
            let obj = {}
            
            for(let i = 0; i < var_list.length; i++){
            	obj[var_list[i]] = window[var_list[i]]
            }

        	let content = JSON.stringify(obj)
            let fp = choose_save_file({default_path: "/my_backup"}) 
            write_file(fp, content)
        }
    ]
})




